<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Grafana</title>
    <url>/post/grafana/</url>
    <content><![CDATA[<p>Grafana是一款用Go语言开发的开源数据可视化工具，可以做数据监控和数据统计，带有告警功能</p>
<hr>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="1-功能特点"><a href="#1-功能特点" class="headerlink" title="1. 功能特点"></a>1. 功能特点</h2><ul>
<li>可视化：快速和灵活的客户端图形具有多种选项。面板插件为许多不同的方式可视化指标和日志。</li>
<li>报警：可视化地为最重要的指标定义警报规则。Grafana将持续评估它们，并发送通知。</li>
<li>通知：警报更改状态时，它会发出通知。接收电子邮件通知。</li>
<li><span id="more"></span></li>
<li>动态仪表盘：使用模板变量创建动态和可重用的仪表板，这些模板变量作为下拉菜单出现在仪表板顶部。</li>
<li>混合数据源：在同一个图中混合不同的数据源!可以根据每个查询指定数据源。这甚至适用于自定义数据源。</li>
<li>注释：注释来自不同数据源图表。将鼠标悬停在事件上可以显示完整的事件元数据和标记。</li>
<li>过滤器：过滤器允许您动态创建新的键/值过滤器，这些过滤器将自动应用于使用该数据源的所有查询。</li>
</ul>
<h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h2><blockquote>
<p>详细安装教程可参考： <a href="http://docs.grafana.org/installation/debian/">http://docs.grafana.org/installation/debian/</a></p>
</blockquote>
<h3 id="2-1-下载安装包"><a href="#2-1-下载安装包" class="headerlink" title="2.1 下载安装包"></a>2.1 下载安装包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget [https://dl.grafana.com/oss/release/grafana-6.0.1-1.x86_64.rpm](https://dl.grafana.com/oss/release/grafana-6.0.1-1.x86_64.rpm)</span><br></pre></td></tr></table></figure>

<h3 id="2-2-安装环境依赖"><a href="#2-2-安装环境依赖" class="headerlink" title="2.2 安装环境依赖"></a>2.2 安装环境依赖</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install initscripts fontconfig  </span><br><span class="line">yum install freetype</span><br><span class="line">yum install urw-fonts</span><br></pre></td></tr></table></figure>

<h3 id="2-3-安装Grafana服务"><a href="#2-3-安装Grafana服务" class="headerlink" title="2.3 安装Grafana服务"></a>2.3 安装Grafana服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -Uvh grafana-6.0.1-1.x86_64.rpm</span><br></pre></td></tr></table></figure>

<h3 id="2-4-插件安装"><a href="#2-4-插件安装" class="headerlink" title="2.4 插件安装"></a>2.4 插件安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用grafana-cli工具安装</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取可用插件列表 </span></span><br><span class="line">grafana-cli plugins list-remote   </span><br><span class="line"><span class="comment">#修改图形为饼状</span></span><br><span class="line">grafana-cli plugins install grafana-piechart-panel</span><br><span class="line"><span class="comment">#安装其他图形插件</span></span><br><span class="line">grafana-cli plugins install grafana-clock-panel</span><br><span class="line"><span class="comment">#钟表形展示</span></span><br><span class="line">grafana-cli plugins install briangann-gauge-panel</span><br><span class="line"><span class="comment">#字符型展示</span></span><br><span class="line">grafana-cli plugins install natel-discrete-panel</span><br><span class="line"><span class="comment">#服务器状态</span></span><br><span class="line">grafana-cli plugins install vonage-status-panel </span><br></pre></td></tr></table></figure>

<h3 id="2-5-插件卸载"><a href="#2-5-插件卸载" class="headerlink" title="2.5 插件卸载"></a>2.5 插件卸载</h3><blockquote>
<p>例：grafana-cli plugins uninstall vonage-status-panel 安装和卸载后需要重启grafana才能够生效</p>
</blockquote>
<h3 id="2-6-启动、重启、关闭"><a href="#2-6-启动、重启、关闭" class="headerlink" title="2.6 启动、重启、关闭"></a>2.6 启动、重启、关闭</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">启动：service grafana-server start</span><br><span class="line">停止：service grafana-server stop</span><br><span class="line">重启：service grafana-server restart</span><br><span class="line">加入开机自启动： chkconfig --add grafana-server on</span><br></pre></td></tr></table></figure>

<h3 id="2-7-启动测试"><a href="#2-7-启动测试" class="headerlink" title="2.7 启动测试"></a>2.7 启动测试</h3><ul>
<li>默认用户密码：admin/admin</li>
<li>访问地址:  服务地址 : <a href="http://localhost:3000/">http://grafana服务地址:3000</a>如果出现登录界面，代表安装启动成功</li>
<li>无法访问本地虚拟机中服务，需设置虚拟机防火墙允许访问</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -F</span><br><span class="line">iptables -P INPUT ACCEPT（设置默认允许规则）  </span><br></pre></td></tr></table></figure>

<h1 id="创建Dashboard"><a href="#创建Dashboard" class="headerlink" title="创建Dashboard"></a>创建Dashboard</h1>]]></content>
      <categories>
        <category>Blogs</category>
      </categories>
  </entry>
  <entry>
    <title>base</title>
    <url>/post/python_base/</url>
    <content><![CDATA[<p><strong>1. 调整图片大小：</strong></p>
<ol>
<li>打开系统自带看图软件，设置图片大小</li>
</ol>
<p><strong>2. python内建函数是C实现的</strong></p>
<p><strong>3. python 字符串自动填充函数</strong></p>
<ul>
<li><code>s.ljust(width, fillchar)</code></li>
</ul>
<p><strong>4. 最长上升子序列</strong></p>
<span id="more"></span>

<ul>
<li>动态规划</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bisect.bisect_left（）插入会自动排序</span><br></pre></td></tr></table></figure>

<p><strong>5. python collections库</strong></p>
<ol>
<li>默认字典（好用）</li>
</ol>
<ul>
<li><code>from collections import defaultdict</code></li>
<li><code>dd= defaultdict(list)</code></li>
</ul>
<ol>
<li>Counter 自动统计元素个数返回字典</li>
</ol>
<ul>
<li><p><code>Counter([1,3,4,5,2,4,5,2])</code></p>
<p><code>Counter(&#123;1: 1, 3: 1, 4: 2, 5: 2, 2: 2&#125;)</code></p>
</li>
</ul>
<p><strong>6. 字符串find和index的区别</strong></p>
<ul>
<li>find 找不到返回-1</li>
<li>index找不到会异常</li>
</ul>
<p><strong>7. 要记得字符串**</strong><code>startwith</code><em><strong>*和*</strong></em><code>endwith</code>**<strong>俩个实用方法，替代查找了</strong></p>
<p><strong>8. python 正则替换（太方便了）</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.sub(<span class="string">r&#x27;(\d+)&#x27;</span>, <span class="string">&#x27;*\g&lt;1&gt;*&#x27;</span>, s)</span><br></pre></td></tr></table></figure>

<ul>
<li>\g&lt;1&gt;代表第一个参数正则式中的一个分组</li>
</ul>
<p>**9. python ****<code>itertools</code>**</p>
<ul>
<li>创建迭代器的工具库</li>
</ul>
<p>**10. datetime 模块 **</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">datetime.datetime(<span class="number">2020</span>, <span class="number">3</span>, <span class="number">5</span>).strftime(<span class="string">&#x27;%j&#x27;</span>)</span><br><span class="line"><span class="comment"># 65</span></span><br></pre></td></tr></table></figure>

<p>计算当前日期是该年份的第多少天</p>
<p>**11. sorted() **</p>
<ul>
<li>Python3，sort方法取消了cmp参数，官方给出的解决方案是进行多次排序，优先级低的字段先排序，然后逐个根据优先级高的字段排序</li>
</ul>
<p><strong>12. python 复制文件</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shutil.copy(old, new)</span><br></pre></td></tr></table></figure>

<p>文件名不带后缀</p>
<p><strong>13. docker</strong></p>
<ul>
<li>镜像:(类)</li>
<li>容器:(实例)</li>
<li>仓库:(管理镜像)</li>
<li>开发者可以打包他们的应用以及依赖包到一个可移植的镜像中 ，方便部署</li>
</ul>
<p><strong>14. sorted 排序 key可以有多个条件</strong></p>
<ul>
<li>a = [2, 1, -9, 3, 4, 5, -3, -7, -101, -8, -54]res = sorted(a, key=lambda x: (x &lt; 0, x))print(res)</li>
</ul>
<p><strong>15.  创建字典新方法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span>([[<span class="number">2</span>, <span class="string">&#x27;t&#x27;</span>]])</span><br><span class="line">&#123;<span class="number">2</span>: <span class="string">&#x27;t&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>双重列表，元组都可</li>
</ul>
<p><strong>16. 生成工程所需安装包</strong></p>
<ul>
<li>终端命令行输入 pip freeze &gt; ./requirements.txt，自动生成到该文件中</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>闭包</title>
    <url>/post/%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h3 id="全局变量-and-局部变量"><a href="#全局变量-and-局部变量" class="headerlink" title="全局变量  and  局部变量"></a>全局变量  and  局部变量</h3><ol>
<li>全局变量：</li>
</ol>
<ul>
<li><p>在整个文件中都能被访问</p>
</li>
<li><p>在函数内部不能修改全局变量</p>
</li>
<li><p>函数内部试图修改全局变量，python的屏蔽机制会在函数内部新建一个和全局变量同名的局部变量</p>
</li>
<li><p>函数内部要想真正修改全局变量，需要在全局变量钱加global</p>
<span id="more"></span></li>
</ul>
<ol>
<li>局部变量：</li>
</ol>
<ul>
<li>只能在函数内部访问</li>
<li>函数的形参是局部变量</li>
</ul>
<h3 id="global-nonlocal"><a href="#global-nonlocal" class="headerlink" title="global/nonlocal"></a>global/nonlocal</h3><ol>
<li>global</li>
</ol>
<ul>
<li>函数内修改全局变量</li>
</ul>
<ol>
<li>nonlocal</li>
</ol>
<ul>
<li>函数内修改外部变量（非全局变量）</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ol>
<li>函数嵌套：</li>
<li>内嵌函数用到外层变量</li>
<li>外部函数返回内嵌函数</li>
<li>功能：</li>
</ol>
<ul>
<li>在不修改原代码的条件下实现新功能</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In[<span class="number">3</span>]:<span class="function"><span class="keyword">def</span> <span class="title">fun1</span>(<span class="params">x</span>):</span></span><br><span class="line">...:      <span class="function"><span class="keyword">def</span> <span class="title">fun2</span>(<span class="params">y</span>):</span></span><br><span class="line">...:          <span class="keyword">nonlocal</span> x</span><br><span class="line">...:           x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">...:       <span class="keyword">return</span> x * y</span><br><span class="line">...:  <span class="keyword">return</span> fun2</span><br><span class="line"></span><br><span class="line">...: fun1(<span class="number">2</span>)(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">Out[<span class="number">3</span>]: <span class="number">9</span></span><br></pre></td></tr></table></figure>

<h3 id="匿名函数-lambda"><a href="#匿名函数-lambda" class="headerlink" title="匿名函数 lambda"></a>匿名函数 lambda</h3><p>lambda x(参数): 返回值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">4</span>]: <span class="keyword">lambda</span> x: x * <span class="number">2</span></span><br><span class="line">Out[<span class="number">4</span>]: &lt;function **main**.&lt;<span class="keyword">lambda</span>&gt;(x)&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: a = <span class="keyword">lambda</span> x: x * <span class="number">2</span></span><br><span class="line">In [<span class="number">6</span>]: a(<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">6</span>]: <span class="number">4</span></span><br><span class="line">In [<span class="number">7</span>]: b = <span class="keyword">lambda</span> x, y: x * y</span><br><span class="line">In [<span class="number">8</span>]: b(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">Out[<span class="number">8</span>]: <span class="number">6</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>图解网络基础知识</title>
    <url>/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="图解网络基础知识"><a href="#图解网络基础知识" class="headerlink" title="图解网络基础知识"></a>图解网络基础知识</h1><p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BD%91%E7%BB%9C.jpg" alt="图片"></p>
<h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>我们用手机连接上网的时候，会用到许多网络协议。从手机连接 WiFi 开始，使用的是 <strong>802.11</strong> （即 WLAN ）协议，通过 WLAN 接入网络；手机自动获取网络配置，使用的是 <strong>DHCP</strong> 协议，获取配置后手机才能正常通信。这时手机已经连入<strong>局域网</strong>，可以访问局域网内的设备和资源，但还不能使用互联网应用，<span id="more"></span>例如：微信、抖音等。想要访问<strong>互联网</strong>，还需要在手机的上联网络设备上实现相关协议，即在无线路由器上配置 <strong>NAT</strong>、 <strong>PPPOE</strong> 等功能，再通过运营商提供的互联网线路把局域网接入到互联网中，手机就可以上网玩微信、刷抖音了。</p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1-1.jpg" alt="图片">网络协议示意图</p>
<blockquote>
<p><strong>局域网</strong> ：小范围内的私有网络，一个家庭内的网络、一个公司内的网络、一个校园内的网络都属于局域网。</p>
<p><strong>广域网</strong>：把不同地域的局域网互相连接起来的网络。运营商搭建广域网实现跨区域的网络互连。</p>
<p><strong>互联网</strong>：互联全世界的网络。互联网是一个开放、互联的网络，不属于任何个人和任何机构，接入互联网后可以和互联网的任何一台主机进行通信。</p>
</blockquote>
<p>简单来说，就是手机、无线路由器等设备通过多种<strong>网络协议</strong>实现通信。网络协议就是为了通信各方能够互相交流而定义的标准或规则，设备只要遵循相同的网络协议就能够实现通信。那网络协议又是谁规定的呢？ISO 制定了一个国际标准 <strong>OSI</strong> ， 其中的 <strong>OSI 参考模型</strong>常被用于网络协议的制定。</p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1-2.jpg" alt="图片">OSI 参考模型图</p>
<h3 id="OSI-参考模型"><a href="#OSI-参考模型" class="headerlink" title="OSI 参考模型"></a>OSI 参考模型</h3><p>OSI 参考模型将网络协议提供的服务分成 <strong>7</strong> 层，并定义每一层的<strong>服务</strong>内容，实现每一层服务的是<strong>协议</strong>，协议的具体内容是<strong>规则</strong>。上下层之间通过<strong>接口</strong>进行交互，同一层之间通过<strong>协议</strong>进行交互。OSI 参考模型只对各层的服务做了粗略的界定，并没有对协议进行详细的定义，但是许多协议都对应了 7 个分层的某一层。所以要了解网络，首先要了解 OSI 参考模型。</p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1-3.jpg" alt="图片">OSI 参考模型分层功能</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>OSI参考模型的第 <strong>7</strong> 层（最高层）。应用程序和网络之间的接口，直接向用户提供服务。应用层协议有电子邮件、远程登录等协议。</p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1-4.jpg" alt="图片">应用层示例图</p>
<h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><p>OSI参考模型的第 <strong>6</strong> 层。负责数据格式的互相转换，如编码、数据格式转换和加密解密等。保证一个系统应用层发出的信息可被另一系统的应用层读出。</p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1-5.jpg" alt="图片">表示层示例图</p>
<h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4><p>OSI参考模型的第 <strong>5</strong> 层。主要是管理和协调不同主机上各种进程之间的通信（对话），即负责建立、管理和终止应用程序之间的会话。</p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1-6.jpg" alt="图片">会话层示例图</p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>OSI参考模型的第 <strong>4</strong> 层。为上层协议提供通信主机间的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。只在通信主机上处理，不需要在路由器上处理。</p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1-7.jpg" alt="图片">传输层示例图</p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>OSI参考模型的第 <strong>3</strong> 层。在网络上将数据传输到目的地址，主要负责寻址和路由选择。</p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1-8.jpg" alt="图片">网络层示例图</p>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>OSI参考模型的第 2 层。负责物理层面上两个互连主机间的通信传输，将由 0 、 1 组成的比特流划分成数据帧传输给对端，即数据帧的生成与接收。通信传输实际上是通过物理的传输介质实现的。数据链路层的作用就是在这些通过传输介质互连的设备之间进行数据处理。</p>
<p>网络层与数据链路层都是基于目标地址将数据发送给接收端的，但是网络层负责将整个数据发送给最终目标地址， 而数据链路层则只负责发送一个分段内的数据。</p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1-9.jpg" alt="图片">数据链路层示例图</p>
<h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>OSI参考模型的第 <strong>1</strong> 层（最底层）。负责逻辑信号（比特流）与物理信号（电信号、光信号）之间的互相转换，通过传输介质为数据链路层提供物理连接。</p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1-10.jpg" alt="图片">物理层示例图</p>
<h3 id="TCP-IP-参考模型"><a href="#TCP-IP-参考模型" class="headerlink" title="TCP/IP 参考模型"></a>TCP/IP 参考模型</h3><p>由于 OSI 参考模型把服务划得过于琐碎，先定义参考模型再定义协议，有点理想化。TCP/IP 模型则正好相反，通过已有的协议归纳总结出来的模型，成为业界的实际网络协议标准。</p>
<p>TCP/IP 是有由 IETF 建议、推进其标准化的一种协议，是 IP 、 TCP 、 HTTP 等协议的集合。TCP/IP 是为使用互联网而开发制定的协议族，所以互联网的协议就是 TCP/IP 。</p>
<p>先介绍下 TCP/IP 与 OSI 分层之间的对应关系，以及 TCP/IP 每层的主要协议。</p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-1.jpg" alt="图片"></p>
<h4 id="网络接入层"><a href="#网络接入层" class="headerlink" title="网络接入层"></a>网络接入层</h4><p>TCP/IP 是以 OSI 参考模型的物理层和数据链路层的功能是透明的为前提制定的，并未对这两层进行定义，所以可以把物理层和数据链路层合并称为<strong>网络接入层</strong>。网络接入层是对网络介质的管理，定义如何使用网络来传送数据。但是在通信过程中这两层起到的作用不一样，所以也有把物理层和数据链路层分别称为<strong>硬件</strong>、<strong>网络接口层</strong>。TCP/IP 分为四层或者五层都可以，只要能理解其中的原理即可。</p>
<p>设备之间通过物理的传输介质互连， 而互连的设备之间使用 <strong>MAC 地址</strong>实现数据传输。采用 MAC 地址，目的是为了识别连接到同一个传输介质上的设备。</p>
<h4 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h4><p>相当于 OSI 模型中的第 3 层网络层，使用 <strong>IP 协议</strong>。IP 协议基于 <strong>IP 地址</strong>转发分包数据，作用是将数据包从源地址发送到目的地址。</p>
<p>TCP/IP 分层中的网络层与传输层的功能通常由<strong>操作系统</strong>提供。 路由器就是通过网络层实现<strong>转发数据包</strong>的功能。</p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-2.jpg" alt="图片">网络层</p>
<p>网络传输中，每个节点会根据数据的地址信息，来判断该报文应该由哪个网卡发送出去。各个地址会参考一个发出接口列表， MAC 寻址中所参考的这张表叫做<strong>MAC 地址转发表</strong>，而 IP 寻址中所参考的叫做<strong>路由控制表</strong>。MAC 地址转发表根据自学自动生成。路由控制表则根据路由协议自动生成。MAC 地址转发表中所记录的是实际的 MAC 地址本身，而路由表中记录的 IP 地址则是集中了之后的网络号（即网络号与子网掩码）。</p>
<ul>
<li><p><strong>IP</strong></p>
<p>IP 是跨越网络传送数据包，使用 IP 地址作为主机的标识，使整个互联网都能收到数据的协议。IP 协议独立于底层介质，实现从源到目的的数据转发。IP 协议不具有重发机制，属于非可靠性传输协议。</p>
</li>
<li><p><strong>ICMP</strong></p>
<p>用于在 IP 主机、路由器之间传递控制消息，用来诊断网络的健康状况。</p>
</li>
<li><p><strong>ARP</strong></p>
<p>从数据包的 IP 地址中解析出 MAC 地址的一种协议。</p>
</li>
</ul>
<h4 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h4><p>相当于 OSI 模型中的第 4 层传输层，主要功能就是让应用程序之间互相通信，通过<strong>端口号</strong>识别应用程序，使用的协议有面向连接的 <strong>TCP</strong> 协议和面向无连接的<strong>UDP</strong> 协议。</p>
<p><strong>面向连接</strong>是在发送数据之前， 在收发主机之间连接一条逻辑通信链路。好比平常打电话，输入完对方电话号码拨出之后，只有对方接通电话才能真正通话，通话结束后将电话机扣上就如同切断电源。</p>
<p><strong>面向无连接</strong>不要求建立和断开连接。发送端可于任何时候自由发送数据。如同去寄信，不需要确认收件人信息是否真实存在，也不需要确认收件人是否能收到信件，只要有个寄件地址就可以寄信了。</p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-3.jpg" alt="图片">传输层</p>
<ul>
<li><p><strong>TCP</strong></p>
<p>TCP 是一种面向有连接的传输层协议，能够对自己提供的连接实施控制。适用于要求<strong>可靠传输</strong>的应用，例如文件传输。</p>
</li>
<li><p><strong>UDP</strong></p>
<p>UDP 是一种面向无连接的传输层协议，不会对自己提供的连接实施控制。适用于<strong>实时</strong>应用，例如：IP电话、视频会议、直播等。</p>
</li>
</ul>
<h4 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h4><p>相当于 OSI 模型中的第 5 - 7 层的集合，不仅要实现 OSI 模型应用层的功能，还要实现会话层和表示层的功能。HTTP 、 POP3 、 TELNET 、 SSH 、 FTP 、 SNMP都是应用层协议。</p>
<p>TCP/IP 应用的架构绝大多数属于<strong>客户端/服务端</strong>模型。提供服务的程序叫服务端， 接受服务的程序叫客户端。客户端可以随时发送请求给服务端。</p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-4.jpg" alt="图片">应用层</p>
<ul>
<li><p><strong>HTTP</strong></p>
<p>是 WWW 浏览器和服务器之间的应用层通信协议，所传输数据的主要格式是 HTML 。HTTP 定义高级命令或者方法供浏览器用来与Web服务器通信。</p>
</li>
<li><p><strong>POP3</strong></p>
<p>简单邮件传输协议，邮件客户端和邮件服务器使用。</p>
</li>
<li><p><strong>TELNET 和 SSH</strong></p>
<p>远程终端协议，用于远程管理网络设备。TELNET 是明文传输， SSH 是加密传输。</p>
</li>
<li><p><strong>SNMP</strong></p>
<p>简单网络管理协议，用于网管软件进行网络设备的监控和管理。</p>
</li>
</ul>
<h4 id="封装与解封装"><a href="#封装与解封装" class="headerlink" title="封装与解封装"></a>封装与解封装</h4><p>通常，为协议提供的信息为包<strong>头部</strong>，所要发送的内容为<strong>数据</strong>。每个分层中，都会对所发送的数据附加一个头部，在这个头部中包含了该层必要的信息， 如发送的目标地址以及协议相关信息。在下一层的角度看，从上一分层收到的包全部都被认为是本层的数据。</p>
<p>数据发送前，按照参考模型从上到下，在数据经过每一层时，添加协议报文头部信息，这个过程叫<strong>封装</strong>。</p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-5.jpg" alt="图片">封装</p>
<p>数据接收后，按照参考模型从下到上，在数据经过每一层时，去掉协议头部信息，这个过程叫<strong>解封装</strong>。</p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-6.jpg" alt="图片">解封装</p>
<p>经过传输层协议封装后的数据称为<strong>段</strong>，经过网络层协议封装后的数据称为<strong>包</strong>，经过数据链路层协议封装后的数据称为<strong>帧</strong>，物理层传输的数据为<strong>比特</strong>。</p>
<p>TCP/IP 通信中使用 MAC 地址、 IP 地址、端口号等信息作为<strong>地址标识</strong>。甚至在应用层中，可以将电子邮件地址作为网络通信的地址。</p>
<h4 id="实际数据传输举例"><a href="#实际数据传输举例" class="headerlink" title="实际数据传输举例"></a>实际数据传输举例</h4><p>实际生活中，互联网是使用的 TCP/IP 协议进行网络连接的。我们以<strong>访问网站</strong>为例，看看网络是如何进行通信的。</p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-7.jpg" alt="图片">数据传输举例</p>
<h5 id="发送数据包"><a href="#发送数据包" class="headerlink" title="发送数据包"></a>发送数据包</h5><p>访问 HTTP 网站页面时，打开浏览器，输入网址，敲下回车键就开始进行 TCP/IP 通信了。</p>
<p><strong>应用程序处理</strong></p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-8.jpg" alt="图片">应用层</p>
<p>首先，应用程序中会进行 HTML 格式<strong>编码</strong>处理，相当于 OSI 的表示层功能。编码转化后，不一定会马上发送出去，相当于会话层的功能。在请求发送的那一刻，建立 TCP 连接，然后在 TCP 连接上发送数据。接下来就是将数据发送给下一层的 TCP 进行处理。</p>
<p><strong>TCP 模块处理</strong></p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-9.jpg" alt="图片">传输层</p>
<p>TCP 会将应用层发来的数据顺利的发送至目的地。实现可靠传输的功能，需要给数据封装 TCP 头部信息。TCP 头部信息包括源端口号和目的端口号（识别主机上应用）、序号（确认哪部分是数据）以及校验和（判断数据是否被损坏）。随后<strong>封装</strong>了 TCP 头部信息的段再发送给 IP 。</p>
<p><strong>IP  模块处理</strong></p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-10.jpg" alt="图片">网络层</p>
<p>IP 将 TCP 传过来的数据段当做自己的数据，并封装 IP 头部信息。IP 头部信息中包含目的 IP 地址和源 IP 地址，以及上层协议类型信息。</p>
<p>IP 包生成后，根据主机<strong>路由表</strong>进行数据发送。</p>
<p><strong>网络接口处理</strong></p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-11.jpg" alt="图片">物理层</p>
<p>网络接口对传过来的 IP 包封装上以太网头部信息并进行发送处理。以太网头部信息包含目的 MAC 地址、源 MAC 地址，以及上层协议类型信息。然后将以太网数据<strong>帧</strong>通过物理层传输给接收端。发送处理中的 FCS 由硬件计算， 添加到包的最后。设置 FCS 的目的是为了判断数据包是否由于噪声而被破坏。</p>
<h5 id="接收数据包"><a href="#接收数据包" class="headerlink" title="接收数据包"></a>接收数据包</h5><p>包的接收流程是发送流程的<strong>反向</strong>过程。</p>
<p><strong>网络接口处理</strong></p>
<p>收到以太网包后，首先查看头部信息的目的 MAC 地址是否是发给自己的包。如果不是发送给自己的包就丢弃。如果是发送给自己的包，查看上层协议类型是 IP 包，以太网帧<strong>解封装</strong>成 IP 包，传给 IP 模块进行处理。如果是无法识别的协议类型，则丢弃数据。</p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-12.jpg" alt="图片">网口处理流程</p>
<p><strong>IP  模块处理</strong></p>
<p>收到 IP 包后，进行类似处理。根据头部信息的目的 IP 地址判断是否是发送给自己包，如果是发送给自己的包，则查看上一层的协议类型。上一层协议是 TCP ，就把 IP 包解封装发送给 TCP 协议处理。</p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-13.jpg" alt="图片">IP模块处理流程</p>
<p>假如有路由器，且接收端不是自己的地址，那么根据路由控制表转发数据。</p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-14.jpg" alt="图片">路由器处理流程</p>
<p><strong>TCP 模块处理</strong></p>
<p>收到 TCP 段后，首先查看校验和，判断数据是否被破坏。然后检查是否按照序号接收数据。最后检查端口号，确定具体的应用程序。</p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-15.jpg" alt="图片">TCP模块处理流程</p>
<p>数据接收完毕后，发送一个 “ <strong>确认回执</strong> ” 给发送端。如果这个回执信息未能达到发送端，那么发送端会认为接收端没有接收到数据而一直反复发送。</p>
<p>数据被完整接收后，会把 TCP 段解封装发送给由端口号识别的应用程序。</p>
<p><strong>应用程序处理</strong></p>
<p>应用程序收到数据后，通过解析数据内容获知发送端请求的网页内容，然后按照 HTTP 协议进行后续数据交互。</p>
<h3 id="网络构成"><a href="#网络构成" class="headerlink" title="网络构成"></a>网络构成</h3><p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-16.jpg" alt="图片">网络构成要素</p>
<p>搭建一套网络涉及各种线缆和网络设备。下面介绍一些常见的<strong>硬件设备</strong>。硬件设备所说的层数是参照的 OSI 参考模型，而不是 TCP/IP 模型。</p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-17.jpg" alt="图片">主要设备及作用表</p>
<h4 id="通信介质与数据链路"><a href="#通信介质与数据链路" class="headerlink" title="通信介质与数据链路"></a>通信介质与数据链路</h4><p>设备之间通过线缆进行连接。有线线缆有双绞线、光纤、串口线等。根据数据链路不同选择对应的线缆。传输介质还可以被分为电波、微波等不同类型的电磁波。</p>
<p><strong>传输速率</strong>：单位为 <code>bps</code> ，是指单位时间内传输的数据量有多少。又称作带宽，带宽越大网络传输能力就越强。</p>
<p><strong>吞吐量</strong>：单位为 <code>bps</code> ，主机之间实际的传输速率。吞吐量这个词不仅衡量带宽， 同时也衡量主机的 CPU 处理能力、 网络的拥堵程度、 报文中数据字段的占有份额等信息。</p>
<h4 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h4><p>任一主机连接网络时，必须要使用网卡。可以是有线网卡，用来连接有线网络，也可以是无线网卡连接 WiFi 网络。每块网卡都有一个唯一的 <strong>MAC 地址</strong>，也叫做硬件地址或物理地址。</p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-18.jpg" alt="图片">网卡</p>
<h4 id="二层交换机"><a href="#二层交换机" class="headerlink" title="二层交换机"></a>二层交换机</h4><p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-19.jpg" alt="图片">二层交换机</p>
<p>二层交换机位于 OSI 模型的第 2 层（数据链路层）。它能够识别数据链路层中的数据帧，并将帧转发给相连的另一个数据链路。</p>
<p>数据帧中有一个数据位叫做 <strong>FCS</strong> ，用以校验数据是否正确送达目的地。二层交换机通过检查这个值，将损坏的数据丢弃。</p>
<p>二层交换机根据 MAC 地址<strong>自学机制</strong>判断是否需要转发数据帧。</p>
<h4 id="路由器-三层交换机"><a href="#路由器-三层交换机" class="headerlink" title="路由器 / 三层交换机"></a>路由器 / 三层交换机</h4><p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-20.jpg" alt="图片">路由器</p>
<p>路由器是在 OSI 模型的第 3 层（网络层）上连接两个网络、并对报文进行转发的设备。二层交换机是根据 MAC 地址进行处理，而路由器 / 三层交换机则是根据<strong>IP 地址</strong>进行处理的。因此 TCP/IP 中网络层的地址就成为了 IP 地址。</p>
<p>路由器可以连接不同的数据链路。比如连接两个以太网，或者连接一个以太网与一个无线网。家庭里面常见的无线路由器也是路由器的一种。</p>
<h4 id="四至七层交换机"><a href="#四至七层交换机" class="headerlink" title="四至七层交换机"></a>四至七层交换机</h4><p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-21.jpg" alt="图片">负载均衡设备</p>
<p>四至七层交换机负责处理 OSI 模型中从传输层至应用层的数据。以 TCP 等协议的传输层及其上面的应用层为基础，分析收发数据，并对其进行特定的处理。例如，视频网站的一台服务器不能满足访问需求，通过<strong>负载均衡设备</strong>将访问分发到后台多个服务器上，就是四至七层交换机的一种。还有带宽控制、广域网加速器、防火墙等应用场景。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-22.jpg" alt="图片">总结</p>
<p>应用层设备有电脑、手机、服务器等。应用层设备<strong>不转发数据</strong>，它们是<strong>数据的源或目的</strong>，拥有应用层以下的各层功能。发送数据时，从上而下的顺序，逐层对数据进行封装，再通过以太网将数据发送出去。接收数据时，从下而上的顺序，逐层对数据进行解封装，最终恢复成原始数据。</p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-23.jpg" alt="图片">应用层处理流程</p>
<p>数据链路层设备有二层交换机、网桥等。二层网络设备<strong>只转发数据</strong>，通过识别数据的 <strong>MAC 地址</strong>进行转发。二层交换机接收数据后，对数据最外层封装的以太网头部信息进行查看，看到数据的目的 MAC 地址后，把数据帧从对应端口发送出去。交换机并不会对数据帧进行解封装，只要知道 MAC 地址信息就可以正确地将数据转发出去。</p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-24.jpg" alt="图片">数据链路层处理流程</p>
<p>网络层设备有路由器、三层交换机等。三层网络设备<strong>只转发数据</strong>，通过识别数据的<strong>IP 地址</strong>进行转发。路由器接收数据后，首先查看最外层封装的以太网头部信息，当目的 MAC 地址是自己时，就会将以太网头部解封装，查看数据的 IP 地址。根据 IP 路由表做出转发决定时，路由器会把下一跳设备的 MAC 地址作为以太网头部的目的 MAC 地址，重新封装以太网头部并将数据转发出去。</p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-25.jpg" alt="图片">网络层处理流程</p>
<p>转发数据的网络设备和应用层的数据，就像<strong>快递员</strong>和<strong>包裹</strong>一样。快递员根据目的地址运送包裹，不必了解包裹里的具体内容。</p>
<p>通过分层功能来区分网络设备已经不再适用，交换机集成三层路由功能就是三层交换机，无线AP集成路由器功能就是无线路由器。但是为了方便说明，通常是介绍单个设备的功能和原理。</p>
<p><img src="/post/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2-26.jpg" alt="图片">无线路由器</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习</title>
    <url>/post/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="1-机器学习分类"><a href="#1-机器学习分类" class="headerlink" title="1 机器学习分类"></a>1 机器学习分类</h1><ul>
<li><p>传统机器学习</p>
<p>机器学习可以理解成是生产算法的算法。需要人来先做特征提取，然后在把特征向量化后交给机器去训练。</p>
<p>传统机器学习分为 <strong>监督学习</strong> 和 <strong>无监督学习</strong>。</p>
</li>
<li><p>深度学习</p>
<p>深度学习是基于深度神经网络的学习（DNN）。深度学习可以自动提取特征。深度学习可以采用 End-to-End 的学习方式，只需要进行很少的归一化和白化，就可以将数据交给模型去训练。</p>
<span id="more"></span></li>
</ul>
<h1 id="2-机器学习中的一些概念"><a href="#2-机器学习中的一些概念" class="headerlink" title="2 机器学习中的一些概念"></a>2 机器学习中的一些概念</h1><p>首先我们需要了解几个机器学习中的起码要知道是怎么回事的概念，了解了后面看代码才不会一脸懵逼。</p>
<ul>
<li><p>训练样本</p>
<p>就是用于训练的数据。包括了现实中的一些信息数据，以及对应的结果，也就是标签。</p>
</li>
<li><p>训练</p>
<p>对训练样本的特征进行统计和归纳的过程。</p>
</li>
<li><p>分类模型</p>
<p>总结出的特征，判断标准。</p>
</li>
<li><p>验证</p>
<p>用测试数据集验证模型是否正确的过程。这个过程是在模型训练完后进行的，就是再用另外一些样本数据，代入到模型中去，看它的准确率如何。</p>
</li>
</ul>
<h2 id="2-1-聚类"><a href="#2-1-聚类" class="headerlink" title="2.1 聚类"></a>2.1 聚类</h2><p><strong>聚类</strong> 是一种典型的 <strong>无监督学习</strong> ，是把数据进行分类的过程。</p>
<p>进行聚类的基本思想是，利用 <strong>向量</strong> 之间的距离 —— 空间中的 <strong>欧式距离</strong> 或 <strong>曼哈顿距离</strong> ， 根据距离的大小判断对象是否应该归为同一类别。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-eac361e6aac5f0a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 12.52.49.png</p>
<p>上图是对3个一维向量分类的例子。明显的能看到，离得近的两个们可以近似的认为它们属于同一类别。</p>
<h2 id="2-2-回归"><a href="#2-2-回归" class="headerlink" title="2.2 回归"></a>2.2 回归</h2><p>回归简单的说就是一个 <strong>由果索因</strong> 的过程。这是机器学习中很常用的一个手段。</p>
<p>回归分为：</p>
<ol>
<li>线性回归</li>
<li>非线性回归</li>
</ol>
<p>实际使用那种回归模型，需要根据情况而定。</p>
<h3 id="2-2-1-线性回归"><a href="#2-2-1-线性回归" class="headerlink" title="2.2.1 线性回归"></a>2.2.1 线性回归</h3><p>线性回归模型：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-d6e145b143c1b1c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/886/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 12.53.54.png</p>
<p>其中 w 是一个特征张量，储存着与每个变量x中元素对应的特征元素，x 就是输入的训练数据张量，b 是一个偏置量。</p>
<p>这其实就是高中概率与统计章节中常见的一个公式。就像解那时候的应用题一样，我们需要根据一堆 （x，y）求解一个合适的 w 和 b。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-54424b4c3cec0c8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 12.54.40.png</p>
<p>看看上面这个应用题，是否想起了高中时代的数学课？哈哈…</p>
<h3 id="2-2-2-损失Loss函数"><a href="#2-2-2-损失Loss函数" class="headerlink" title="2.2.2 损失Loss函数"></a>2.2.2 损失Loss函数</h3><p>损失函数是用来评估模型预测结果和真实情况差距的，差距越小，说明我们的模型越好，越准确。</p>
<p>这，就是损失函数的公式！</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-e21d51abf5ac1a4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 12.55.16.png</p>
<p>当我们假设一个 w 和 b 后，循环计算每一个 x 所得的值和真实 x 所对应的值相减，然后将每一个差相加求和，得到一个差值之和，就是当前的损失。</p>
<p>损失越小，说明所寻找到的 w 和 b 就越合适，当 Loss 为 0 时，说明此时模型的准确率为 100% 。</p>
<p>事实上，这和高中概率与统计应用题，给你一堆 x，y ，然后求一个 系数w 和 常量b 出来是一样的一样的。只不过在计算机中，由于算力比手算强大太多了，所以我们可以一遍一遍的调整 w 和 b 这两个参数，使 Loss 一直向趋于 0 的方向移动 ，从而使模型的准确率趋于 100% 。</p>
<p>通常，为了使 Loss 始终保持为正 ，也会有如下损失函数：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-bd2fc1fd311a70b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1006/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 12.55.54.png</p>
<p>求平方使得结果横为正数。</p>
<p>比如这个函数的图像可能是一个三维的碗，那么我们的任务就是找到碗底的位置，也就是极值，因为在该点有解，即损失最小。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-8cfdef591a3e183d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="2-2-3-梯度下降法寻找最优解"><a href="#2-2-3-梯度下降法寻找最优解" class="headerlink" title="2.2.3 梯度下降法寻找最优解"></a>2.2.3 梯度下降法寻找最优解</h3><p>对于复杂函数，我们要直接求解是巨困难的，甚至有时可以说是处于不可解的状态。我们需要寻找损失函数的极值，可以使用牛顿迭代法的思想进行迭代寻找。</p>
<p>那对于复杂函数是不是就只能束手无策了呢？在你了解 <strong>牛顿迭代法</strong> 之后就可以回到不是了，而此前对于这个问题也许只能回答不能了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-94b807c7b69f9136.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/850/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 12.57.12.png</p>
<p>通过迭代，我们可以逐步的逼近索要寻找的极值。</p>
<p>这里，我们还人为的引入了一个 η 参数，这个参数用于调整步长。步子迈大了可能会越过极值，迈小了有会产生很大的计算量，具体取多大合适，还是要多看看老司机们烫过的坑。</p>
<p><strong>普通的梯度下降法（批梯度下降法，BGD</strong>），需要遍历所有的数据样本，在样本量不大的时候还是可以的，毕竟这么干精度起码是很高的。但是如果样本容量巨大，那每次遍历所有样本，必然都会消耗很多时间成本。并且如果我们的损失函数不是一个凸函数误差曲面就会存在多个局部极小值（即局部碗底），那采用这种方法可能会陷入局部最优解中。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-4e5161497a3b0d0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/692/format/webp" alt="img"></p>
<p>image</p>
<p>如上图就是一个非凸损失函数，有可能在梯度下降的过程中走到了一个局部最低点去，而这其实不是真正的最低点。</p>
<p>为了加快收敛速度，<strong>随机梯度下降法（SGD）</strong> 就诞生了。它的思想是每次仅随机的抽取样本总体中的一个样本，来决定下一步的走向。它的好处是不用遍历所有的样本，所以对于样本容量巨大的情况，能够极大的加快收敛。但可想而知，每次随便取一个样本来更新权值，最终的权值很可能并不是最优解，不过有时在考虑现实情况的时候，这点精度误差也是可接受的。</p>
<p>那我们可不可以既要速度，又要精度呢？当 CoorChice 这么问的时候，你可就是知道套路问题的套路答案了（也许下次 CoorChice 就不会按套路走了，啊哈哈！）。答案就是 <strong>小批梯度下降法（Mini-batch GD）</strong>。它的思想是每次选取一定量的样本进行训练，然后再更新权值。即不用全部遍历，也不会因为每次更新仅由一个样本来决定而损失过多的精度。两头兼顾，当然也比较中庸。</p>
<h3 id="2-2-4-交叉熵"><a href="#2-2-4-交叉熵" class="headerlink" title="2.2.4 交叉熵"></a>2.2.4 交叉熵</h3><p>在了解交叉熵之前，先了解一下什么是信息熵？</p>
<p>首先看两个相关公式。</p>
<p>信息量公式：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-7124737a6bb85f98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 12.57.49.png</p>
<p>没错，通过对一种情况发生的先验概率进行对数计算的结果，被用来表征这种事件发生的信息量。</p>
<p>信息熵公式：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-2d0dde70f4cbb078.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 12.58.10.png</p>
<p>就是将所有事件的信息熵进行加和。这个值越大，表明对于预测一个事件而言的不确定性就越大。</p>
<p>上面的公式是 <strong>信息熵</strong> 公式，它表示对于一系列事件，根据其历史发生数据可以计算出一个先验概率，根据这个先验概率，可以计算出该事件发生的信息量，再将信息量乘以先验概率，就可以得到单个事件的熵。将这些事件的熵求和，就可以得到信息熵了。它有什么作用呢？就是用来量化信息量的，如果越不确定，则其信息熵就越大。对于一个有序的系统（按部就班）来说，它的信息熵就比较小了。</p>
<p>如果理解了信息熵，接下来就可以更进一步的了解交叉熵了。</p>
<p>首先，交叉熵损失函数如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-cb819b5e50b4878a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 12.58.16.png</p>
<p>y 表示期望输出值，a 表示实际模型的输出。</p>
<p>交叉熵是用来干什么的呢？它表示的训练结果和实际标签结果的差距。</p>
<p>交叉熵函数也有这种常用的形式：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-938971a7683718ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/930/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 12.58.21.png</p>
<p>通常交叉熵会和 Softmax 激励函数一起在输出层计算输出。</p>
<h1 id="3-深度学习的基本概念"><a href="#3-深度学习的基本概念" class="headerlink" title="3 深度学习的基本概念"></a>3 深度学习的基本概念</h1><p>深度学习是基于深度神经网络的学习。它的概念类似与人的神经结构，由神经元可链接成一个神经网络，每个神经元被作为一个网络节点。</p>
<p>好像一下又回到了生物课！</p>
<p>深度学习相对于传统的机器学习来说，很明显的优势在于能够自动提取特征，可将线性不可分的问题转变为线性可分的问题。</p>
<p>使用传统机器学习，不管用朴素贝叶斯、决策树、支持向量机SVM等分类模型之前，必须对大量的模型进行处理，人工的从中提取特征用于量化。而在深度学习中，通过大量的线性分类器的堆叠，加上一些非线性因素，可以使一些特征能够自动的显现出来，而干扰因素经过过滤也能很大程度的被忽略。</p>
<p>总之，这种方式的机器学习肯定是更加先进的，但是需要消耗的资源也会更大。</p>
<p>深度学习由于是自动提取特征的，所以会导致我们有时候无法判断处究竟为什么会是这个模型，不便于我们分析问题，它就像一个黑盒一样，给它数据，它给你结果，而你很难了解里面发生了什么。</p>
<h2 id="3-1-神经元的组成"><a href="#3-1-神经元的组成" class="headerlink" title="3.1 神经元的组成"></a>3.1 神经元的组成</h2><p>通常，一个神经元由一个 <strong>“线性模型”</strong> 和 一个 <strong>“激励函数”</strong> 组成。线性模型其实就是上面提到过的线性回归模型。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-5f82f7dfef67fdf5.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/771/format/webp" alt="img"></p>
<p>image</p>
<p>如图就是一个神经网络，它共有两层，一个是神经元层（隐含层），一个是输出层。通常我们在说一个网络的深度时，是不会把输入层不计入的。</p>
<p>在神经元中，有一个线性模型 <strong>wx + b</strong> 和 一个激活函数 <strong>f</strong>。</p>
<p>我们的数据将会通过一个个的神经元，每个神经元都有一组权重，用于提取一类特征，相当于是我们把数据进行了一层一层的剖析。</p>
<h2 id="3-2-激励函数"><a href="#3-2-激励函数" class="headerlink" title="3.2 激励函数"></a>3.2 激励函数</h2><p>激励函数，通常也会被称为激活函数，它是跟随在 <code>f(x) = wx + b</code> 函数之后，用来加入一些非线性的因素的。通过激活函数，可以将线性函数作为输入，经过激活函数后，变成非线性的，这样一来就更接近真实世界的复杂情况了。</p>
<p>列举几个常用的激活函数，有助理解。</p>
<h3 id="3-2-1-Sigmoid函数"><a href="#3-2-1-Sigmoid函数" class="headerlink" title="3.2.1 Sigmoid函数"></a>3.2.1 Sigmoid函数</h3><p><img src="https://upload-images.jianshu.io/upload_images/1869462-0e2af88bea0e0e75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 13.00.17.png</p>
<p>图像</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-5d00e0b26cb066d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 13.00.23.png</p>
<p>从函数可以看到，这个函数的值域为 （0，1），0.5值处为函数的对称中心。有时在 &lt;-4 和 &gt;4 的区间中，函数曲线越来越趋于水平，也就是导数很趋于0，这会导致梯度下降时，我们的对权值的更新微乎其微，也就是出现梯度消失的问题。</p>
<p>当然，它作为比较常用的激励函数，有其自己很适用的问题领域，比如二分类问题。</p>
<h3 id="3-2-2-ReLu函数"><a href="#3-2-2-ReLu函数" class="headerlink" title="3.2.2 ReLu函数"></a>3.2.2 ReLu函数</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">y <span class="operator">=</span> <span class="built_in">max</span>(x, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>图像</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-745433e20c13aa64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>这是个很受欢迎的函数，光是看看它简洁的函数式你就不能拒绝它！</p>
<p>这个函数在 &gt; 0 的时候，输入就等于输出，计算量会小很多，所以收敛速度会快很多。</p>
<h3 id="3-2-3-Softmax"><a href="#3-2-3-Softmax" class="headerlink" title="3.2.3 Softmax"></a>3.2.3 Softmax</h3><p><img src="https://upload-images.jianshu.io/upload_images/1869462-d8df014d7ac97720.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/614/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 13.00.48.png</p>
<p>这个函数看起来比较复杂，它通常被用于处理多分类问题。可以看看它的定义式，就是个体在总体中的占比情况。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-1fa05f4ec0c9e1c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 13.02.09.png</p>
<p>从图中可以很直观的看出这个函数的功能，就是各种分类的概率啊。</p>
<h2 id="3-3-独热编码"><a href="#3-3-独热编码" class="headerlink" title="3.3 独热编码"></a>3.3 独热编码</h2><p>对于多分类问题，标注分类可以使用使用 <strong>独热编码</strong> 来进行，比如这样一个例子：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-35a4f40718ed8801.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/492/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 13.02.39.png</p>
<p>就是说，有几个类型就定义一个几维的向量，然后向量中只有一个元素为1，其余均为0，通过1在向量中的位置来表示类型。</p>
<h2 id="3-3-过拟合和欠拟合"><a href="#3-3-过拟合和欠拟合" class="headerlink" title="3.3 过拟合和欠拟合"></a>3.3 过拟合和欠拟合</h2><p>在训练过程中，可能会因为过拟合或者欠拟合而导致最终训练出来的模型准确率不足或者因泛化性差而导致准确率低。</p>
<ul>
<li><p>欠拟合</p>
<p>样本过少，无法归纳出足够的共性</p>
</li>
<li><p>过拟合</p>
<p>参数过多，导致在训练集上准确率很高，但换新样本会严重误判。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在了解了机器学习是干什么的之后，又了解了一些基本概念在机器学习中会被经常用到的，相信你对机器学习也不会保持一种敬畏感了，知道它很厉害，但是不知道为什么厉害。</p>
<p>现在开始，可以试着到 TensorFlow 官网看一些入门的 code 例子，然后结合这些概念理解下每个步骤是在干什么，为什么要这么做？</p>
<p>在前面，大家也会看到，在机器学习中用到了很多统计学的知识，所以很多人会认为机器学习其实就是统计学而已。实际上 CoorChice 认为，机器学习只是用了统计学作为工具，去研究解决问题，实际上它是有一套自己的理论和套路的，就像物理用数据作为工具去解决问题一样。机器学习在解决实际问题的过程中，会需要很多学科的交叉来分析问题，构建模型。当然，总体的思想看起来还是很简单的，只不过面对真世界中的复杂情况下，其探寻求解过程会比较复杂。</p>
<h1 id="1-机器学习分类-1"><a href="#1-机器学习分类-1" class="headerlink" title="1 机器学习分类"></a>1 机器学习分类</h1><ul>
<li><p>传统机器学习</p>
<p>机器学习可以理解成是生产算法的算法。需要人来先做特征提取，然后在把特征向量化后交给机器去训练。</p>
<p>传统机器学习分为 <strong>监督学习</strong> 和 <strong>无监督学习</strong>。</p>
</li>
<li><p>深度学习</p>
<p>深度学习是基于深度神经网络的学习（DNN）。深度学习可以自动提取特征。深度学习可以采用 End-to-End 的学习方式，只需要进行很少的归一化和白化，就可以将数据交给模型去训练。</p>
</li>
</ul>
<h1 id="2-机器学习中的一些概念-1"><a href="#2-机器学习中的一些概念-1" class="headerlink" title="2 机器学习中的一些概念"></a>2 机器学习中的一些概念</h1><p>首先我们需要了解几个机器学习中的起码要知道是怎么回事的概念，了解了后面看代码才不会一脸懵逼。</p>
<ul>
<li><p>训练样本</p>
<p>就是用于训练的数据。包括了现实中的一些信息数据，以及对应的结果，也就是标签。</p>
</li>
<li><p>训练</p>
<p>对训练样本的特征进行统计和归纳的过程。</p>
</li>
<li><p>分类模型</p>
<p>总结出的特征，判断标准。</p>
</li>
<li><p>验证</p>
<p>用测试数据集验证模型是否正确的过程。这个过程是在模型训练完后进行的，就是再用另外一些样本数据，代入到模型中去，看它的准确率如何。</p>
</li>
</ul>
<h2 id="2-1-聚类-1"><a href="#2-1-聚类-1" class="headerlink" title="2.1 聚类"></a>2.1 聚类</h2><p><strong>聚类</strong> 是一种典型的 <strong>无监督学习</strong> ，是把数据进行分类的过程。</p>
<p>进行聚类的基本思想是，利用 <strong>向量</strong> 之间的距离 —— 空间中的 <strong>欧式距离</strong> 或 <strong>曼哈顿距离</strong> ， 根据距离的大小判断对象是否应该归为同一类别。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-eac361e6aac5f0a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 12.52.49.png</p>
<p>上图是对3个一维向量分类的例子。明显的能看到，离得近的两个们可以近似的认为它们属于同一类别。</p>
<h2 id="2-2-回归-1"><a href="#2-2-回归-1" class="headerlink" title="2.2 回归"></a>2.2 回归</h2><p>回归简单的说就是一个 <strong>由果索因</strong> 的过程。这是机器学习中很常用的一个手段。</p>
<p>回归分为：</p>
<ol>
<li>线性回归</li>
<li>非线性回归</li>
</ol>
<p>实际使用那种回归模型，需要根据情况而定。</p>
<h3 id="2-2-1-线性回归-1"><a href="#2-2-1-线性回归-1" class="headerlink" title="2.2.1 线性回归"></a>2.2.1 线性回归</h3><p>线性回归模型：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-d6e145b143c1b1c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/886/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 12.53.54.png</p>
<p>其中 w 是一个特征张量，储存着与每个变量x中元素对应的特征元素，x 就是输入的训练数据张量，b 是一个偏置量。</p>
<p>这其实就是高中概率与统计章节中常见的一个公式。就像解那时候的应用题一样，我们需要根据一堆 （x，y）求解一个合适的 w 和 b。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-54424b4c3cec0c8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 12.54.40.png</p>
<p>看看上面这个应用题，是否想起了高中时代的数学课？哈哈…</p>
<h3 id="2-2-2-损失Loss函数-1"><a href="#2-2-2-损失Loss函数-1" class="headerlink" title="2.2.2 损失Loss函数"></a>2.2.2 损失Loss函数</h3><p>损失函数是用来评估模型预测结果和真实情况差距的，差距越小，说明我们的模型越好，越准确。</p>
<p>这，就是损失函数的公式！</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-e21d51abf5ac1a4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 12.55.16.png</p>
<p>当我们假设一个 w 和 b 后，循环计算每一个 x 所得的值和真实 x 所对应的值相减，然后将每一个差相加求和，得到一个差值之和，就是当前的损失。</p>
<p>损失越小，说明所寻找到的 w 和 b 就越合适，当 Loss 为 0 时，说明此时模型的准确率为 100% 。</p>
<p>事实上，这和高中概率与统计应用题，给你一堆 x，y ，然后求一个 系数w 和 常量b 出来是一样的一样的。只不过在计算机中，由于算力比手算强大太多了，所以我们可以一遍一遍的调整 w 和 b 这两个参数，使 Loss 一直向趋于 0 的方向移动 ，从而使模型的准确率趋于 100% 。</p>
<p>通常，为了使 Loss 始终保持为正 ，也会有如下损失函数：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-bd2fc1fd311a70b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1006/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 12.55.54.png</p>
<p>求平方使得结果横为正数。</p>
<p>比如这个函数的图像可能是一个三维的碗，那么我们的任务就是找到碗底的位置，也就是极值，因为在该点有解，即损失最小。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-8cfdef591a3e183d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="2-2-3-梯度下降法寻找最优解-1"><a href="#2-2-3-梯度下降法寻找最优解-1" class="headerlink" title="2.2.3 梯度下降法寻找最优解"></a>2.2.3 梯度下降法寻找最优解</h3><p>对于复杂函数，我们要直接求解是巨困难的，甚至有时可以说是处于不可解的状态。我们需要寻找损失函数的极值，可以使用牛顿迭代法的思想进行迭代寻找。</p>
<p>那对于复杂函数是不是就只能束手无策了呢？在你了解 <strong>牛顿迭代法</strong> 之后就可以回到不是了，而此前对于这个问题也许只能回答不能了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-94b807c7b69f9136.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/850/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 12.57.12.png</p>
<p>通过迭代，我们可以逐步的逼近索要寻找的极值。</p>
<p>这里，我们还人为的引入了一个 η 参数，这个参数用于调整步长。步子迈大了可能会越过极值，迈小了有会产生很大的计算量，具体取多大合适，还是要多看看老司机们烫过的坑。</p>
<p><strong>普通的梯度下降法（批梯度下降法，BGD</strong>），需要遍历所有的数据样本，在样本量不大的时候还是可以的，毕竟这么干精度起码是很高的。但是如果样本容量巨大，那每次遍历所有样本，必然都会消耗很多时间成本。并且如果我们的损失函数不是一个凸函数误差曲面就会存在多个局部极小值（即局部碗底），那采用这种方法可能会陷入局部最优解中。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-4e5161497a3b0d0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/692/format/webp" alt="img"></p>
<p>image</p>
<p>如上图就是一个非凸损失函数，有可能在梯度下降的过程中走到了一个局部最低点去，而这其实不是真正的最低点。</p>
<p>为了加快收敛速度，<strong>随机梯度下降法（SGD）</strong> 就诞生了。它的思想是每次仅随机的抽取样本总体中的一个样本，来决定下一步的走向。它的好处是不用遍历所有的样本，所以对于样本容量巨大的情况，能够极大的加快收敛。但可想而知，每次随便取一个样本来更新权值，最终的权值很可能并不是最优解，不过有时在考虑现实情况的时候，这点精度误差也是可接受的。</p>
<p>那我们可不可以既要速度，又要精度呢？当 CoorChice 这么问的时候，你可就是知道套路问题的套路答案了（也许下次 CoorChice 就不会按套路走了，啊哈哈！）。答案就是 <strong>小批梯度下降法（Mini-batch GD）</strong>。它的思想是每次选取一定量的样本进行训练，然后再更新权值。即不用全部遍历，也不会因为每次更新仅由一个样本来决定而损失过多的精度。两头兼顾，当然也比较中庸。</p>
<h3 id="2-2-4-交叉熵-1"><a href="#2-2-4-交叉熵-1" class="headerlink" title="2.2.4 交叉熵"></a>2.2.4 交叉熵</h3><p>在了解交叉熵之前，先了解一下什么是信息熵？</p>
<p>首先看两个相关公式。</p>
<p>信息量公式：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-7124737a6bb85f98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 12.57.49.png</p>
<p>没错，通过对一种情况发生的先验概率进行对数计算的结果，被用来表征这种事件发生的信息量。</p>
<p>信息熵公式：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-2d0dde70f4cbb078.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 12.58.10.png</p>
<p>就是将所有事件的信息熵进行加和。这个值越大，表明对于预测一个事件而言的不确定性就越大。</p>
<p>上面的公式是 <strong>信息熵</strong> 公式，它表示对于一系列事件，根据其历史发生数据可以计算出一个先验概率，根据这个先验概率，可以计算出该事件发生的信息量，再将信息量乘以先验概率，就可以得到单个事件的熵。将这些事件的熵求和，就可以得到信息熵了。它有什么作用呢？就是用来量化信息量的，如果越不确定，则其信息熵就越大。对于一个有序的系统（按部就班）来说，它的信息熵就比较小了。</p>
<p>如果理解了信息熵，接下来就可以更进一步的了解交叉熵了。</p>
<p>首先，交叉熵损失函数如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-cb819b5e50b4878a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 12.58.16.png</p>
<p>y 表示期望输出值，a 表示实际模型的输出。</p>
<p>交叉熵是用来干什么的呢？它表示的训练结果和实际标签结果的差距。</p>
<p>交叉熵函数也有这种常用的形式：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-938971a7683718ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/930/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 12.58.21.png</p>
<p>通常交叉熵会和 Softmax 激励函数一起在输出层计算输出。</p>
<h1 id="3-深度学习的基本概念-1"><a href="#3-深度学习的基本概念-1" class="headerlink" title="3 深度学习的基本概念"></a>3 深度学习的基本概念</h1><p>深度学习是基于深度神经网络的学习。它的概念类似与人的神经结构，由神经元可链接成一个神经网络，每个神经元被作为一个网络节点。</p>
<p>好像一下又回到了生物课！</p>
<p>深度学习相对于传统的机器学习来说，很明显的优势在于能够自动提取特征，可将线性不可分的问题转变为线性可分的问题。</p>
<p>使用传统机器学习，不管用朴素贝叶斯、决策树、支持向量机SVM等分类模型之前，必须对大量的模型进行处理，人工的从中提取特征用于量化。而在深度学习中，通过大量的线性分类器的堆叠，加上一些非线性因素，可以使一些特征能够自动的显现出来，而干扰因素经过过滤也能很大程度的被忽略。</p>
<p>总之，这种方式的机器学习肯定是更加先进的，但是需要消耗的资源也会更大。</p>
<p>深度学习由于是自动提取特征的，所以会导致我们有时候无法判断处究竟为什么会是这个模型，不便于我们分析问题，它就像一个黑盒一样，给它数据，它给你结果，而你很难了解里面发生了什么。</p>
<h2 id="3-1-神经元的组成-1"><a href="#3-1-神经元的组成-1" class="headerlink" title="3.1 神经元的组成"></a>3.1 神经元的组成</h2><p>通常，一个神经元由一个 <strong>“线性模型”</strong> 和 一个 <strong>“激励函数”</strong> 组成。线性模型其实就是上面提到过的线性回归模型。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-5f82f7dfef67fdf5.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/771/format/webp" alt="img"></p>
<p>image</p>
<p>如图就是一个神经网络，它共有两层，一个是神经元层（隐含层），一个是输出层。通常我们在说一个网络的深度时，是不会把输入层不计入的。</p>
<p>在神经元中，有一个线性模型 <strong>wx + b</strong> 和 一个激活函数 <strong>f</strong>。</p>
<p>我们的数据将会通过一个个的神经元，每个神经元都有一组权重，用于提取一类特征，相当于是我们把数据进行了一层一层的剖析。</p>
<h2 id="3-2-激励函数-1"><a href="#3-2-激励函数-1" class="headerlink" title="3.2 激励函数"></a>3.2 激励函数</h2><p>激励函数，通常也会被称为激活函数，它是跟随在 <code>f(x) = wx + b</code> 函数之后，用来加入一些非线性的因素的。通过激活函数，可以将线性函数作为输入，经过激活函数后，变成非线性的，这样一来就更接近真实世界的复杂情况了。</p>
<p>列举几个常用的激活函数，有助理解。</p>
<h3 id="3-2-1-Sigmoid函数-1"><a href="#3-2-1-Sigmoid函数-1" class="headerlink" title="3.2.1 Sigmoid函数"></a>3.2.1 Sigmoid函数</h3><p><img src="https://upload-images.jianshu.io/upload_images/1869462-0e2af88bea0e0e75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 13.00.17.png</p>
<p>图像</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-5d00e0b26cb066d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 13.00.23.png</p>
<p>从函数可以看到，这个函数的值域为 （0，1），0.5值处为函数的对称中心。有时在 &lt;-4 和 &gt;4 的区间中，函数曲线越来越趋于水平，也就是导数很趋于0，这会导致梯度下降时，我们的对权值的更新微乎其微，也就是出现梯度消失的问题。</p>
<p>当然，它作为比较常用的激励函数，有其自己很适用的问题领域，比如二分类问题。</p>
<h3 id="3-2-2-ReLu函数-1"><a href="#3-2-2-ReLu函数-1" class="headerlink" title="3.2.2 ReLu函数"></a>3.2.2 ReLu函数</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">y <span class="operator">=</span> <span class="built_in">max</span>(x, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>图像</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-745433e20c13aa64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>这是个很受欢迎的函数，光是看看它简洁的函数式你就不能拒绝它！</p>
<p>这个函数在 &gt; 0 的时候，输入就等于输出，计算量会小很多，所以收敛速度会快很多。</p>
<h3 id="3-2-3-Softmax-1"><a href="#3-2-3-Softmax-1" class="headerlink" title="3.2.3 Softmax"></a>3.2.3 Softmax</h3><p><img src="https://upload-images.jianshu.io/upload_images/1869462-d8df014d7ac97720.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/614/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 13.00.48.png</p>
<p>这个函数看起来比较复杂，它通常被用于处理多分类问题。可以看看它的定义式，就是个体在总体中的占比情况。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-1fa05f4ec0c9e1c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 13.02.09.png</p>
<p>从图中可以很直观的看出这个函数的功能，就是各种分类的概率啊。</p>
<h2 id="3-3-独热编码-1"><a href="#3-3-独热编码-1" class="headerlink" title="3.3 独热编码"></a>3.3 独热编码</h2><p>对于多分类问题，标注分类可以使用使用 <strong>独热编码</strong> 来进行，比如这样一个例子：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1869462-35a4f40718ed8801.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/492/format/webp" alt="img"></p>
<p>屏幕快照 2018-10-05 13.02.39.png</p>
<p>就是说，有几个类型就定义一个几维的向量，然后向量中只有一个元素为1，其余均为0，通过1在向量中的位置来表示类型。</p>
<h2 id="3-3-过拟合和欠拟合-1"><a href="#3-3-过拟合和欠拟合-1" class="headerlink" title="3.3 过拟合和欠拟合"></a>3.3 过拟合和欠拟合</h2><p>在训练过程中，可能会因为过拟合或者欠拟合而导致最终训练出来的模型准确率不足或者因泛化性差而导致准确率低。</p>
<ul>
<li><p>欠拟合</p>
<p>样本过少，无法归纳出足够的共性</p>
</li>
<li><p>过拟合</p>
<p>参数过多，导致在训练集上准确率很高，但换新样本会严重误判。</p>
</li>
</ul>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>在了解了机器学习是干什么的之后，又了解了一些基本概念在机器学习中会被经常用到的，相信你对机器学习也不会保持一种敬畏感了，知道它很厉害，但是不知道为什么厉害。</p>
<p>现在开始，可以试着到 TensorFlow 官网看一些入门的 code 例子，然后结合这些概念理解下每个步骤是在干什么，为什么要这么做？</p>
<p>在前面，大家也会看到，在机器学习中用到了很多统计学的知识，所以很多人会认为机器学习其实就是统计学而已。实际上 CoorChice 认为，机器学习只是用了统计学作为工具，去研究解决问题，实际上它是有一套自己的理论和套路的，就像物理用数据作为工具去解决问题一样。机器学习在解决实际问题的过程中，会需要很多学科的交叉来分析问题，构建模型。当然，总体的思想看起来还是很简单的，只不过面对真世界中的复杂情况下，其探寻求解过程会比较复杂。</p>
]]></content>
  </entry>
  <entry>
    <title>最全面的Python重点</title>
    <url>/post/%E6%9C%80%E5%85%A8%E9%9D%A2%E7%9A%84Python%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[<h1 id="最全面的Python重点"><a href="#最全面的Python重点" class="headerlink" title="最全面的Python重点"></a>最全面的Python重点</h1><h3 id="1-Py2-VS-Py3"><a href="#1-Py2-VS-Py3" class="headerlink" title="1. Py2 VS Py3"></a>1. Py2 VS Py3</h3><ul>
<li><p>print成为了函数，python2是关键字</p>
</li>
<li><p>不再有unicode对象，默认str就是unicode</p>
</li>
<li><p>python3除号返回浮点数</p>
</li>
<li><p>没有了long类型</p>
<span id="more"></span></li>
<li><p>xrange不存在，range替代了xrange</p>
</li>
<li><p>可以使用中文定义函数名变量名</p>
</li>
<li><p>高级解包 和*解包</p>
</li>
<li><p>限定关键字参数 *后的变量必须加入名字=值</p>
</li>
<li><p>raise from</p>
</li>
<li><p>iteritems移除变成items()</p>
</li>
<li><p>yield from 链接子生成器</p>
</li>
<li><p>asyncio,async/await原生协程支持异步编程</p>
</li>
<li><p>新增 enum, mock, ipaddress, concurrent.futures, asyncio urllib, selector</p>
<ul>
<li>不同枚举类间不能进行比较</li>
<li>同一枚举类间只能进行相等的比较</li>
<li>枚举类的使用(编号默认从1开始)</li>
<li>为了避免枚举类中相同枚举值的出现，可以使用@unique装饰枚举类</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#枚举的注意事项</span></span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">COLOR</span>(<span class="params">Enum</span>):</span></span><br><span class="line">    YELLOW=<span class="number">1</span></span><br><span class="line"><span class="comment">#YELLOW=2#会报错</span></span><br><span class="line">    GREEN=<span class="number">1</span><span class="comment">#不会报错,GREEN可以看作是YELLOW的别名</span></span><br><span class="line">    BLACK=<span class="number">3</span></span><br><span class="line">    RED=<span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(COLOR.GREEN)<span class="comment">#COLOR.YELLOW,还是会打印出YELLOW</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> COLOR:<span class="comment">#遍历一下COLOR并不会有GREEN</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment">#COLOR.YELLOW\nCOLOR.BLACK\nCOLOR.RED\n怎么把别名遍历出来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> COLOR.__members__.items():</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment"># output:(&#x27;YELLOW&#x27;, &lt;COLOR.YELLOW: 1&gt;)\n(&#x27;GREEN&#x27;, &lt;COLOR.YELLOW: 1&gt;)\n(&#x27;BLACK&#x27;, &lt;COLOR.BLACK: 3&gt;)\n(&#x27;RED&#x27;, &lt;COLOR.RED: 4&gt;)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> COLOR.__members__:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment"># output:YELLOW\nGREEN\nBLACK\nRED</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#枚举转换</span></span><br><span class="line"><span class="comment">#最好在数据库存取使用枚举的数值而不是使用标签名字字符串</span></span><br><span class="line"><span class="comment">#在代码里面使用枚举类</span></span><br><span class="line">a=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(COLOR(a))<span class="comment"># output:COLOR.YE</span></span><br></pre></td></tr></table></figure>

<h3 id="2-常用及重要的库"><a href="#2-常用及重要的库" class="headerlink" title="2. 常用及重要的库"></a>2. 常用及重要的库</h3><ul>
<li><p>必须知道的collections</p>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000017385799">https://segmentfault.com/a/1190000017385799</a></p>
</blockquote>
</li>
<li><p>python排序操作及heapq模块</p>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000017383322">https://segmentfault.com/a/1190000017383322</a></p>
</blockquote>
</li>
<li><p>itertools模块超实用方法</p>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000017416590">https://segmentfault.com/a/1190000017416590</a></p>
</blockquote>
</li>
</ul>
<h4 id="2-1-不常用但很重要的库"><a href="#2-1-不常用但很重要的库" class="headerlink" title="2.1 不常用但很重要的库"></a>2.1 不常用但很重要的库</h4><ul>
<li><p>dis(代码字节码分析)</p>
</li>
<li><p>inspect(生成器状态)</p>
</li>
<li><p>cProfile(性能分析)</p>
</li>
<li><p>bisect(维护有序列表)</p>
</li>
<li><p>fnmatch</p>
<ul>
<li><p>fnmatch(string,”*.txt”)  win下不区分大小写</p>
</li>
<li><p>fnmatch根据系统决定</p>
</li>
<li><p>fnmatchcase完全区分大小写</p>
</li>
</ul>
</li>
<li><p>timeit(代码执行时间)</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isLen</span>(<span class="params">strString</span>):</span></span><br><span class="line">        <span class="comment">#还是应该使用三元表达式，更快</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> <span class="built_in">len</span>(strString)&gt;<span class="number">6</span> <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isLen1</span>(<span class="params">strString</span>):</span></span><br><span class="line">        <span class="comment">#这里注意false和true的位置</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="literal">False</span>,<span class="literal">True</span>][<span class="built_in">len</span>(strString)&gt;<span class="number">6</span>]</span><br><span class="line">    <span class="keyword">import</span> timeit</span><br><span class="line">    <span class="built_in">print</span>(timeit.timeit(<span class="string">&#x27;isLen1(&quot;5fsdfsdfsaf&quot;)&#x27;</span>,setup=<span class="string">&quot;from __main__ import isLen1&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(timeit.timeit(<span class="string">&#x27;isLen(&quot;5fsdfsdfsaf&quot;)&#x27;</span>,setup=<span class="string">&quot;from __main__ import isLen&quot;</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li><p>contextlib</p>
<ul>
<li>@contextlib.contextmanager使生成器函数变成一个上下文管理器</li>
</ul>
</li>
<li><p>types(包含了标准解释器定义的所有类型的类型对象,可以将生成器函数修饰为异步模式)</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> types    types.coroutine <span class="comment">#相当于实现了__await__</span></span><br></pre></td></tr></table></figure>

<ul>
<li>html(实现对html的转义)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> html</span><br><span class="line">    html.escape(<span class="string">&quot;&lt;h1&gt;I&#x27;m Jim&lt;/h1&gt;&quot;</span>) <span class="comment"># output:&#x27;&amp;lt;h1&amp;gt;I&amp;#x27;m Jim&amp;lt;/h1&amp;gt;&#x27;</span></span><br><span class="line">    html.unescape(<span class="string">&#x27;&amp;lt;h1&amp;gt;I&amp;#x27;m Jim&amp;lt;/h1&amp;gt;&#x27;</span>) <span class="comment"># &lt;h1&gt;I&#x27;m Jim&lt;/h1&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>mock(解决测试依赖)</li>
<li>concurrent(创建进程池和线程池)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor()</span><br><span class="line">task = pool.submit(函数名，（参数）) <span class="comment">#此方法不会阻塞，会立即返回</span></span><br><span class="line">task.done()<span class="comment">#查看任务执行是否完成</span></span><br><span class="line">task.result()<span class="comment">#阻塞的方法，查看任务返回值</span></span><br><span class="line">task.cancel()<span class="comment">#取消未执行的任务，返回True或False,取消成功返回True</span></span><br><span class="line">task.add_done_callback()<span class="comment">#回调函数</span></span><br><span class="line">task.running()<span class="comment">#是否正在执行     task就是一个Future对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> pool.<span class="built_in">map</span>(函数，参数列表):<span class="comment">#返回已经完成的任务结果列表，根据参数顺序执行</span></span><br><span class="line">    <span class="built_in">print</span>(返回任务完成得执行结果data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> as_completed</span><br><span class="line">as_completed(任务列表)<span class="comment">#返回已经完成的任务列表，完成一个执行一个</span></span><br><span class="line"></span><br><span class="line">wait(任务列表,return_when=条件)<span class="comment">#根据条件进行阻塞主线程，有四个条件</span></span><br></pre></td></tr></table></figure>

<ul>
<li>selector(封装select,用户多路复用io编程)</li>
<li>asyncio</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">future=asyncio.ensure_future(协程)  等于后面的方式  future=loop.create_task(协程)</span><br><span class="line">future.add_done_callback()添加一个完成后的回调函数</span><br><span class="line">loop.run_until_complete(future)</span><br><span class="line">future.result()查看写成返回结果</span><br><span class="line"></span><br><span class="line">asyncio.wait()接受一个可迭代的协程对象</span><br><span class="line">asynicio.gather(*可迭代对象,*可迭代对象）    两者结果相同，但gather可以批量取消，gather对象.cancel()</span><br><span class="line"></span><br><span class="line">一个线程中只有一个loop</span><br><span class="line"></span><br><span class="line">在loop.stop时一定要loop.run_forever()否则会报错</span><br><span class="line">loop.run_forever()可以执行非协程</span><br><span class="line">最后执行<span class="keyword">finally</span>模块中 loop.close()</span><br><span class="line"></span><br><span class="line">asyncio.Task.all_tasks()拿到所有任务 然后依次迭代并使用任务.cancel()取消</span><br><span class="line"></span><br><span class="line">偏函数partial(函数，参数)把函数包装成另一个函数名  其参数必须放在定义函数的前面</span><br><span class="line"></span><br><span class="line">loop.call_soon(函数,参数)</span><br><span class="line">call_soon_threadsafe()线程安全    </span><br><span class="line">loop.call_later(时间,函数,参数)</span><br><span class="line">在同一代码块中call_soon优先执行，然后多个later根据时间的升序进行执行</span><br><span class="line"></span><br><span class="line">如果非要运行有阻塞的代码</span><br><span class="line">使用loop.run_in_executor(executor,函数，参数)包装成一个多线程，然后放入到一个task列表中，通过wait(task列表)来运行</span><br><span class="line"></span><br><span class="line">通过asyncio实现http</span><br><span class="line">reader,writer=<span class="keyword">await</span> asyncio.open_connection(host,port)</span><br><span class="line">writer.writer()发送请求</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">for</span> data <span class="keyword">in</span> reader:</span><br><span class="line">    data=data.decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="built_in">list</span>.append(data)</span><br><span class="line">然后<span class="built_in">list</span>中存储的就是html</span><br><span class="line"></span><br><span class="line">as_completed(tasks)完成一个返回一个,返回的是一个可迭代对象    </span><br><span class="line"></span><br><span class="line">协程锁</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> Lock():</span><br></pre></td></tr></table></figure>

<h3 id="3-Python进阶"><a href="#3-Python进阶" class="headerlink" title="3. Python进阶"></a>3. Python进阶</h3><h4 id="3-1-进程间通信："><a href="#3-1-进程间通信：" class="headerlink" title="3.1 进程间通信："></a>3.1 进程间通信：</h4><ul>
<li>Manager(内置了好多数据结构，可以实现多进程间内存共享)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager,Process</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_data</span>(<span class="params">p_dict, key, value</span>):</span></span><br><span class="line">    p_dict[key] = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    progress_dict = Manager().<span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"></span><br><span class="line">    first_progress = Process(target=add_data, args=(progress_dict, <span class="string">&quot;bobby1&quot;</span>, <span class="number">22</span>))</span><br><span class="line">    second_progress = Process(target=add_data, args=(progress_dict, <span class="string">&quot;bobby2&quot;</span>, <span class="number">23</span>))</span><br><span class="line"></span><br><span class="line">    first_progress.start()</span><br><span class="line">    second_progress.start()</span><br><span class="line">    first_progress.join()</span><br><span class="line">    second_progress.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(progress_dict)</span><br></pre></td></tr></table></figure>



<ul>
<li>Pipe(适用于两个进程)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pipe,Process</span><br><span class="line"><span class="comment">#pipe的性能高于queue</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">pipe</span>):</span></span><br><span class="line">    pipe.send(<span class="string">&quot;bobby&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">pipe</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(pipe.recv())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    recevie_pipe, send_pipe = Pipe()</span><br><span class="line">    <span class="comment">#pipe只能适用于两个进程</span></span><br><span class="line">    my_producer= Process(target=producer, args=(send_pipe, ))</span><br><span class="line">    my_consumer = Process(target=consumer, args=(recevie_pipe,))</span><br><span class="line"></span><br><span class="line">    my_producer.start()</span><br><span class="line">    my_consumer.start()</span><br><span class="line">    my_producer.join()</span><br><span class="line">    my_consumer.join()</span><br></pre></td></tr></table></figure>



<ul>
<li>Queue(不能用于进程池,进程池间通信需要使用Manager().Queue())</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue,Process</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">queue</span>):</span></span><br><span class="line">    queue.put(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">queue</span>):</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    data = queue.get()</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    queue = Queue(<span class="number">10</span>)</span><br><span class="line">    my_producer = Process(target=producer, args=(queue,))</span><br><span class="line">    my_consumer = Process(target=consumer, args=(queue,))</span><br><span class="line">    my_producer.start()</span><br><span class="line">    my_consumer.start()</span><br><span class="line">    my_producer.join()</span><br><span class="line">    my_consumer.join()</span><br></pre></td></tr></table></figure>



<ul>
<li>进程池</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">queue</span>):</span></span><br><span class="line">    queue.put(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">queue</span>):</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    data = queue.get()</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    queue = Manager().Queue(<span class="number">10</span>)</span><br><span class="line">    pool = Pool(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    pool.apply_async(producer, args=(queue,))</span><br><span class="line">    pool.apply_async(consumer, args=(queue,))</span><br><span class="line"></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure>



<h4 id="3-2-常用方法"><a href="#3-2-常用方法" class="headerlink" title="3.2 常用方法"></a>3.2 常用方法</h4><ul>
<li><p>sys模块几个常用方法</p>
<ul>
<li><p>argv 命令行参数list,第一个是程序本身的路径</p>
</li>
<li><p>path 返回模块的搜索路径</p>
</li>
<li><p>modules.keys() 返回已经导入的所有模块的列表</p>
</li>
<li><p>exit(0) 退出程序</p>
</li>
</ul>
</li>
<li><p>a in s or b in s or c in s简写</p>
<ul>
<li>采用any方式：all() 对于任何可迭代对象为空都会返回True</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"> <span class="literal">True</span> <span class="keyword">in</span> [i <span class="keyword">in</span> s <span class="keyword">for</span> i <span class="keyword">in</span> [a,b,c]]</span><br><span class="line"> <span class="comment"># 方法二</span></span><br><span class="line"> <span class="built_in">any</span>(i <span class="keyword">in</span> s <span class="keyword">for</span> i <span class="keyword">in</span> [a,b,c])</span><br><span class="line"> <span class="comment"># 方法三</span></span><br><span class="line"> <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x <span class="keyword">in</span> s,[a,b,c]))</span><br></pre></td></tr></table></figure>



<ul>
<li><p>set集合运用</p>
<ul>
<li><p>{1,2}.issubset({1,2,3}) 判断是否是其子集</p>
</li>
<li><p>{1,2,3}.issuperset({1,2})</p>
</li>
<li><p>{}.isdisjoint({}) 判断两个set交集是否为空,是空集则为True</p>
</li>
</ul>
</li>
<li><p>代码中中文匹配</p>
<ul>
<li>[u4E00-u9FA5]匹配中文文字区间[一到龥]</li>
</ul>
</li>
<li><p>查看系统默认编码格式</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys    sys.getdefaultencoding()    <span class="comment"># setdefaultencodeing()设置系统编码方式</span></span><br></pre></td></tr></table></figure>



<ul>
<li>getattr VS getattribute</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">dict</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self,value</span>):</span><span class="comment">#当访问属性不存在的时候返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self,item</span>):</span><span class="comment">#屏蔽所有的元素访问</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure>



<ul>
<li><p>类变量是不会存入实例__dict__中的，只会存在于类的__dict__中</p>
</li>
<li><p>globals/locals(可以变相操作代码)</p>
<ul>
<li><p>globals中保存了当前模块中所有的变量属性与值</p>
</li>
<li><p>locals中保存了当前环境中的所有变量属性与值</p>
</li>
</ul>
</li>
<li><p>python变量名的解析机制(LEGB)</p>
<ul>
<li><p>本地作用域(Local)</p>
</li>
<li><p>当前作用域被嵌入的本地作用域(Enclosing locals)</p>
</li>
<li><p>全局/模块作用域(Global)</p>
</li>
<li><p>内置作用域(Built-in)</p>
</li>
</ul>
</li>
<li><p>实现从1-100每三个为一组分组</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>([[x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>)][i:i+<span class="number">3</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">100</span>,<span class="number">3</span>)])</span><br></pre></td></tr></table></figure>



<ul>
<li>什么是元类？</li>
<li>即创建类的类，创建类的时候只需要将metaclass=元类，元类需要继承type而不是object,因为type就是元类</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>.__bases__  <span class="comment">#(&lt;class &#x27;object&#x27;&gt;,)</span></span><br><span class="line"><span class="built_in">object</span>.__bases__    <span class="comment">#()</span></span><br><span class="line"><span class="built_in">type</span>(<span class="built_in">object</span>)    <span class="comment">#&lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Yuan</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls,name,base,attr,*args,**kwargs</span>):</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">type</span>(name,base,attr,*args,**kwargs)</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>(<span class="params">metaclass=Yuan</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>什么是鸭子类型(即:多态)？</p>
<ul>
<li>Python在使用传入参数的过程中不会默认判断参数类型，只要参数具备执行条件就可以执行</li>
</ul>
</li>
<li><p>深拷贝和浅拷贝</p>
<ul>
<li><p>深拷贝拷贝内容，浅拷贝拷贝地址(增加引用计数)</p>
</li>
<li><p>copy模块实现神拷贝</p>
</li>
</ul>
</li>
<li><p>单元测试</p>
<ul>
<li><p>一般测试类继承模块unittest下的TestCase</p>
</li>
<li><p>pytest模块快捷测试(方法以test_开头/测试文件以test_开头/测试类以Test开头，并且不能带有 init 方法)</p>
</li>
<li><p>coverage统计测试覆盖率</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span>(<span class="params">self</span>):</span><span class="comment"># 每个测试用例执行前执行</span></span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&#x27;本方法开始测试了&#x27;</span>)</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">setUp</span>(<span class="params">self</span>):</span><span class="comment"># 每个测试用例执行之前做操作</span></span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&#x27;本方法测试结束&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">     @classmethod</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">tearDownClass</span>(<span class="params">self</span>):</span><span class="comment"># 必须使用 @ classmethod装饰器, 所有test运行完后运行一次</span></span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&#x27;开始测试&#x27;</span>)</span><br><span class="line"><span class="meta">     @classmethod</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">setUpClass</span>(<span class="params">self</span>):</span><span class="comment"># 必须使用@classmethod 装饰器,所有test运行前运行一次</span></span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&#x27;结束测试&#x27;</span>)</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">test_a_run</span>(<span class="params">self</span>):</span></span><br><span class="line">         self.assertEqual(<span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># 测试用例</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>gil会根据执行的字节码行数以及时间片释放gil，gil在遇到io的操作时候主动释放</p>
</li>
<li><p>什么是monkey patch?</p>
<ul>
<li>猴子补丁，在运行的时候替换掉会阻塞的语法修改为非阻塞的方法</li>
</ul>
</li>
<li><p>什么是自省(Introspection)？</p>
<ul>
<li>运行时判断一个对象的类型的能力，id,type,isinstance</li>
</ul>
</li>
<li><p>python是值传递还是引用传递？</p>
<ul>
<li>都不是，python是共享传参，默认参数在执行时只会执行一次</li>
</ul>
</li>
<li><p>try-except-else-finally中else和finally的区别</p>
<ul>
<li><p>else在不发生异常的时候执行，finally无论是否发生异常都会执行</p>
</li>
<li><p>except一次可以捕获多个异常，但一般为了对不同异常进行不同处理，我们分次捕获处理</p>
</li>
</ul>
</li>
<li><p>GIL全局解释器锁</p>
<ul>
<li><p>同一时间只能有一个线程执行，CPython(IPython)的特点，其他解释器不存在</p>
</li>
<li><p>cpu密集型：多进程+进程池</p>
</li>
<li><p>io密集型：多线程/协程</p>
</li>
</ul>
</li>
<li><p>什么是Cython</p>
<ul>
<li>将python解释成C代码工具</li>
</ul>
</li>
<li><p>生成器和迭代器</p>
<ul>
<li><p>可迭代对象只需要实现__iter__方法</p>
<ul>
<li>实现__next__和__iter__方法的对象就是迭代器</li>
</ul>
</li>
<li><p>使用生成器表达式或者yield的生成器函数(生成器是一种特殊的迭代器)</p>
</li>
</ul>
</li>
<li><p>什么是协程</p>
<ul>
<li><p>yield</p>
</li>
<li><p>async-awiat</p>
<ul>
<li>比线程更轻量的多任务方式</li>
<li>实现方式</li>
</ul>
</li>
</ul>
</li>
<li><p>dict底层结构</p>
<ul>
<li><p>为了支持快速查找使用了哈希表作为底层结构</p>
</li>
<li><p>哈希表平均查找时间复杂度为o(1)</p>
</li>
<li><p>CPython解释器使用二次探查解决哈希冲突问题</p>
</li>
</ul>
</li>
<li><p>Hash扩容和Hash冲突解决方案</p>
<ul>
<li><p>链接法</p>
</li>
<li><p>二次探查(开放寻址法)：python使用</p>
<ul>
<li>循环复制到新空间实现扩容</li>
<li>冲突解决：</li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey    monkey.patch_all()  <span class="comment">#将代码中所有的阻塞方法都进行修改，可以指定具体要修改的方法</span></span><br></pre></td></tr></table></figure>



<ul>
<li>判断是否为生成器或者协程</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">co_flags = func.__code__.co_flags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否是协程</span></span><br><span class="line"><span class="keyword">if</span> co_flags &amp; <span class="number">0x180</span>:</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否是生成器</span></span><br><span class="line"><span class="keyword">if</span> co_flags &amp; <span class="number">0x20</span>:</span><br><span class="line">    <span class="keyword">return</span> func</span><br></pre></td></tr></table></figure>



<ul>
<li>斐波那契解决的问题及变形</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</span></span><br><span class="line"><span class="comment">#请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</span></span><br><span class="line"><span class="comment">#方式一：</span></span><br><span class="line">fib = <span class="keyword">lambda</span> n: n <span class="keyword">if</span> n &lt;= <span class="number">2</span> <span class="keyword">else</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line"><span class="comment">#方式二：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">n</span>):</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line"><span class="comment">#一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</span></span><br><span class="line">fib = <span class="keyword">lambda</span> n: n <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> <span class="number">2</span> * fib(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<ul>
<li>获取电脑设置的环境变量</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os    </span><br><span class="line">os.getenv(env_name,<span class="literal">None</span>)<span class="comment">#获取环境变量如果不存在为None</span></span><br></pre></td></tr></table></figure>



<ul>
<li>垃圾回收机制<ul>
<li>引用计数</li>
<li>标记清除</li>
<li>分代回收</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看分代回收触发    </span></span><br><span class="line"><span class="keyword">import</span> gc    gc.get_threshold()  <span class="comment">#output:(700, 10, 10)</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>True和False在代码中完全等价于1和0,可以直接和数字进行计算，inf表示无穷大</p>
</li>
<li><p>C10M/C10K</p>
<ul>
<li>C10M:8核心cpu，64G内存，在10gbps的网络上保持1000万并发连接</li>
<li>C10K：1GHz CPU,2G内存，1gbps网络环境下保持1万个客户端提供FTP服务</li>
</ul>
</li>
<li><p>yield from与yield的区别：</p>
<ul>
<li>yield from跟的是一个可迭代对象，而yield后面没有限制</li>
<li>GeneratorExit生成器停止时触发</li>
</ul>
</li>
<li><p>单下划线的几种使用</p>
<ul>
<li><p>在定义变量时，表示为私有变量</p>
</li>
<li><p>在解包时，表示舍弃无用的数据</p>
</li>
<li><p>在交互模式中表示上一次代码执行结果</p>
</li>
<li><p>可以做数字的拼接(111_222_333)</p>
</li>
</ul>
</li>
<li><p>使用break就不会执行else</p>
</li>
<li><p>10进制转2进制</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conver_bin</span>(<span class="params">num</span>):</span></span><br><span class="line">       <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">           <span class="keyword">return</span> num</span><br><span class="line">       re = []</span><br><span class="line">       <span class="keyword">while</span> num:</span><br><span class="line">           num, rem = <span class="built_in">divmod</span>(num,<span class="number">2</span>)</span><br><span class="line">           re.append(<span class="built_in">str</span>(rem))</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(<span class="built_in">reversed</span>(re))</span><br><span class="line">   conver_bin(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>



<ul>
<li>list1 = [‘A’, ‘B’, ‘C’, ‘D’] 如何才能得到以list中元素命名的新列表 A=[],B=[],C=[],D=[]呢</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">    <span class="built_in">globals</span>()[i] = []   <span class="comment"># 可以用于实现python版反射</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">    <span class="built_in">exec</span>(<span class="string">f&#x27;<span class="subst">&#123;i&#125;</span> = []&#x27;</span>)   <span class="comment"># exec执行字符串语句</span></span><br></pre></td></tr></table></figure>



<ul>
<li>memoryview与bytearray</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bytearray是可变的，bytes是不可变的,memoryview不会产生新切片和对象</span></span><br><span class="line"> a = <span class="string">&#x27;aaaaaa&#x27;</span></span><br><span class="line"> ma = <span class="built_in">memoryview</span>(a)</span><br><span class="line"> ma.readonly  <span class="comment"># 只读的memoryview</span></span><br><span class="line"> mb = ma[:<span class="number">2</span>]  <span class="comment"># 不会产生新的字符串</span></span><br><span class="line"></span><br><span class="line"> a = <span class="built_in">bytearray</span>(<span class="string">&#x27;aaaaaa&#x27;</span>)</span><br><span class="line"> ma = <span class="built_in">memoryview</span>(a)</span><br><span class="line"> ma.readonly  <span class="comment"># 可写的memoryview</span></span><br><span class="line"> mb = ma[:<span class="number">2</span>]      <span class="comment"># 不会会产生新的bytearray</span></span><br><span class="line"> mb[:<span class="number">2</span>] = <span class="string">&#x27;bb&#x27;</span>    <span class="comment"># 对mb的改动就是对ma的改动</span></span><br></pre></td></tr></table></figure>



<ul>
<li>Ellipsis类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码中出现...省略号的现象就是一个Ellipsis对象</span></span><br><span class="line">L = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">L.append(L)</span><br><span class="line"><span class="built_in">print</span>(L)    <span class="comment"># output:[1,2,3,[…]]</span></span><br></pre></td></tr></table></figure>



<ul>
<li>lazy惰性计算</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lazy</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, func</span>):</span></span><br><span class="line">            self.func = func</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, cls</span>):</span></span><br><span class="line">            val = self.func(instance)    <span class="comment">#其相当于执行的area(c),c为下面的Circle对象</span></span><br><span class="line">            <span class="built_in">setattr</span>(instance, self.func.__name__, val)</span><br><span class="line">            <span class="keyword">return</span> val`</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Circle</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, radius</span>):</span></span><br><span class="line">            self.radius = radius</span><br><span class="line"></span><br><span class="line"><span class="meta">        @lazy</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">area</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;evalute&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3.14</span> * self.radius ** <span class="number">2</span></span><br></pre></td></tr></table></figure>



<ul>
<li>遍历文件，传入一个文件夹，将里面所有文件的路径打印出来(递归)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">all_files = []    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllFiles</span>(<span class="params">directory_path</span>):</span></span><br><span class="line">    <span class="keyword">import</span> os                                       </span><br><span class="line">    <span class="keyword">for</span> sChild <span class="keyword">in</span> os.listdir(directory_path):                </span><br><span class="line">        sChildPath = os.path.join(directory_path,sChild)</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(sChildPath):</span><br><span class="line">            getAllFiles(sChildPath)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            all_files.append(sChildPath)</span><br><span class="line">    <span class="keyword">return</span> all_files</span><br></pre></td></tr></table></figure>



<ul>
<li>文件存储时，文件名的处理</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#secure_filename将字符串转化为安全的文件名</span></span><br><span class="line"><span class="keyword">from</span> werkzeug <span class="keyword">import</span> secure_filename</span><br><span class="line">secure_filename(<span class="string">&quot;My cool movie.mov&quot;</span>) <span class="comment"># output:My_cool_movie.mov</span></span><br><span class="line">secure_filename(<span class="string">&quot;../../../etc/passwd&quot;</span>) <span class="comment"># output:etc_passwd</span></span><br><span class="line">secure_filename(<span class="string">u&#x27;i contain cool \xfcml\xe4uts.txt&#x27;</span>) <span class="comment"># output:i_contain_cool_umlauts.txt</span></span><br></pre></td></tr></table></figure>



<ul>
<li>日期格式化</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">datetime.now().strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#这里只有localtime可以被格式化，time是不能格式化的</span></span><br><span class="line">time.strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>,time.localtime())</span><br></pre></td></tr></table></figure>



<ul>
<li>tuple使用+=奇怪的问题</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 会报错，但是tuple的值会改变，因为t[1]id没有发生变化</span></span><br><span class="line">t=(<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">t[<span class="number">1</span>]+=[<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="comment"># t[1]使用append\extend方法并不会报错，并可以成功执行</span></span><br></pre></td></tr></table></figure>



<ul>
<li>__missing__你应该知道</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mydict</span>(<span class="params"><span class="built_in">dict</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span>(<span class="params">self,key</span>):</span> <span class="comment"># 当Mydict使用切片访问属性不存在的时候返回的值</span></span><br><span class="line">        <span class="keyword">return</span> key</span><br></pre></td></tr></table></figure>



<ul>
<li>+与+=</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># +不能用来连接列表和元祖，而+=可以（通过iadd实现，内部实现方式为extends(),所以可以增加元组），+会创建新对象</span></span><br><span class="line"><span class="comment">#不可变对象没有__iadd__方法，所以直接使用的是__add__方法，因此元祖可以使用+=进行元祖之间的相加</span></span><br></pre></td></tr></table></figure>



<ul>
<li>如何将一个可迭代对象的每个元素变成一个字典的所有键？</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span>.fromkeys([<span class="string">&#x27;jim&#x27;</span>,<span class="string">&#x27;han&#x27;</span>],<span class="number">21</span>) <span class="comment"># output:&#123;&#x27;jim&#x27;: 21, &#x27;han&#x27;: 21&#125;</span></span><br></pre></td></tr></table></figure>



<ul>
<li>wireshark抓包软件</li>
</ul>
<h3 id="4-网络知识"><a href="#4-网络知识" class="headerlink" title="4. 网络知识"></a>4. 网络知识</h3><ul>
<li><p>什么是HTTPS?</p>
<ul>
<li>安全的HTTP协议，https需要cs证书，数据加密，端口为443，安全，同一网站https seo排名会更高</li>
</ul>
</li>
<li><p>常见响应状态码</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">204</span> No Content //请求成功处理，没有实体的主体返回，一般用来表示删除成功</span><br><span class="line">    <span class="number">206</span> Partial Content //Get范围请求已成功处理</span><br><span class="line">    <span class="number">303</span> See Other //临时重定向，期望使用get定向获取</span><br><span class="line">    <span class="number">304</span> Not Modified //请求缓存资源</span><br><span class="line">    <span class="number">307</span> Temporary Redirect //临时重定向，Post不会变成Get</span><br><span class="line">    <span class="number">401</span> Unauthorized //认证失败</span><br><span class="line">    <span class="number">403</span> Forbidden //资源请求被拒绝</span><br><span class="line">    <span class="number">400</span> //请求参数错误</span><br><span class="line">    <span class="number">201</span> //添加或更改成功</span><br><span class="line">    <span class="number">503</span> //服务器维护或者超负载</span><br></pre></td></tr></table></figure>



<ul>
<li><p>http请求方法的幂等性及安全性</p>
</li>
<li><p>WSGI</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># environ：一个包含所有HTTP请求信息的dict对象</span></span><br><span class="line">    <span class="comment"># start_response：一个发送HTTP响应的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">application</span>(<span class="params">environ, start_response</span>):</span></span><br><span class="line">        start_response(<span class="string">&#x27;200 OK&#x27;</span>, [(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html&#x27;</span>)])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;h1&gt;Hello, web!&lt;/h1&gt;&#x27;</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>RPC</p>
</li>
<li><p>CDN</p>
</li>
<li><p>SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。</p>
</li>
<li><p>SSH（安全外壳协议） 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。</p>
</li>
<li><p>TCP/IP</p>
<ul>
<li><p>TCP:面向连接/可靠/基于字节流</p>
</li>
<li><p>UDP:无连接/不可靠/面向报文</p>
</li>
<li><p>三次握手四次挥手</p>
<ul>
<li>三次握手(SYN/SYN+ACK/ACK)</li>
<li>四次挥手(FIN/ACK/FIN/ACK)</li>
</ul>
</li>
<li><p>为什么连接的时候是三次握手，关闭的时候却是四次握手？</p>
<ul>
<li>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</li>
</ul>
</li>
<li><p>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</p>
<ul>
<li>虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</li>
</ul>
</li>
</ul>
</li>
<li><p>XSS/CSRF</p>
<ul>
<li>HttpOnly禁止js脚本访问和操作Cookie,可以有效防止XSS</li>
</ul>
</li>
</ul>
<h3 id="5-Mysql"><a href="#5-Mysql" class="headerlink" title="5. Mysql"></a>5. Mysql</h3><ul>
<li><p>索引改进过程</p>
<ul>
<li>线性结构-&gt;二分查找-&gt;hash-&gt;二叉查找树-&gt;平衡二叉树-&gt;多路查找树-&gt;多路平衡查找树(B-Tree)</li>
</ul>
</li>
<li><p>Mysql面试总结基础篇</p>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000018371218">https://segmentfault.com/a/1190000018371218</a></p>
</blockquote>
</li>
<li><p>Mysql面试总结进阶篇</p>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000018380324">https://segmentfault.com/a/1190000018380324</a></p>
</blockquote>
</li>
<li><p>深入浅出Mysql</p>
<p><a href="http://ningning.today/2017/02/13/database/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAmysql/">http://ningning.today/2017/02/13/database/深入浅出mysql/</a></p>
</li>
<li><p>清空整个表时，InnoDB是一行一行的删除，而MyISAM则会从新删除建表</p>
</li>
<li><p>text/blob数据类型不能有默认值，查询时不存在大小写转换</p>
</li>
<li><p>什么时候索引失效</p>
<ul>
<li><p>以%开头的like模糊查询</p>
</li>
<li><p>出现隐式类型转换</p>
</li>
<li><p>没有满足最左前缀原则</p>
<ul>
<li>对于多列索引，不是使用的第一部分，则不会使用索引</li>
</ul>
</li>
<li><p>失效场景：</p>
<ul>
<li><p>应尽量避免在 where 子句中使用 != 或 &lt;&gt; 操作符，否则引擎将放弃使用索引而进行全表扫描</p>
</li>
<li><p>尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，即使其中有条件带索引也不会使用，这也是为什么尽量少用 or 的原因</p>
</li>
<li><p>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不会使用索引</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> <span class="built_in">substring</span>(name,<span class="number">1</span>,<span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span> – name;</span><br><span class="line">以abc开头的，应改成：</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;abc%&#x27;</span> </span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> datediff(<span class="keyword">day</span>, createdate, <span class="string">&#x27;2005-11-30&#x27;</span>) <span class="operator">=</span> <span class="number">0</span> – <span class="string">&#x27;2005-11-30&#x27;</span>;</span><br><span class="line">应改为:</span><br></pre></td></tr></table></figure></li>
<li><p>不要在 where 子句中的 “=” 左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">如：</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">/</span><span class="number">2</span> <span class="operator">=</span> <span class="number">100</span> </span><br><span class="line">应改为:</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="operator">=</span> <span class="number">100</span><span class="operator">*</span><span class="number">2</span>；</span><br></pre></td></tr></table></figure></li>
<li><p>不适合键值较少的列（重复数据较多的列）比如：set enum列就不适合(枚举类型(enum)可以添加null,并且默认的值会自动过滤空格集合(set)和枚举类似，但只可以添加64个值)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>如果MySQL估计使用全表扫描要比使用索引快，则不使用索引</p>
</li>
<li><p>什么是聚集索引</p>
<ul>
<li><p>B+Tree叶子节点保存的是数据还是指针</p>
</li>
<li><p>MyISAM索引和数据分离，使用非聚集</p>
</li>
<li><p>InnoDB数据文件就是索引文件，主键索引就是聚集索引</p>
</li>
</ul>
</li>
</ul>
<h3 id="6-Redis命令总结"><a href="#6-Redis命令总结" class="headerlink" title="6. Redis命令总结"></a>6. Redis命令总结</h3><ul>
<li><p>为什么这么快？</p>
<ul>
<li><p>基于内存，由C语言编写</p>
</li>
<li><p>使用多路I/O复用模型，非阻塞IO</p>
</li>
<li><p>使用单线程减少线程间切换</p>
<ul>
<li>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。</li>
</ul>
</li>
<li><p>数据结构简单</p>
</li>
<li><p>自己构建了VM机制，减少调用系统函数的时间</p>
</li>
</ul>
</li>
<li><p>优势</p>
<ul>
<li>性能高 – Redis能读的速度是110000次/s,写的速度是81000次/s</li>
<li>丰富的数据类型</li>
<li>原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行</li>
<li>丰富的特性 – Redis还支持 publish/subscribe（发布/订阅）, 通知, key 过期等等特性</li>
</ul>
</li>
<li><p>什么是redis事务？</p>
<ul>
<li>将多个请求打包，一次性、按序执行多个命令的机制</li>
<li>通过multi,exec,watch等命令实现事务功能</li>
<li>Python redis-py pipeline=conn.pipeline(transaction=True)</li>
</ul>
</li>
<li><p>持久化方式</p>
<ul>
<li><p>RDB(快照)</p>
<ul>
<li>save(同步，可以保证数据一致性)</li>
<li>bgsave(异步，shutdown时，无AOF则默认使用)</li>
</ul>
</li>
<li><p>AOF(追加日志)</p>
</li>
</ul>
</li>
<li><p>怎么实现队列</p>
<ul>
<li>push</li>
<li>rpop</li>
</ul>
</li>
<li><p>常用的数据类型(Bitmaps,Hyperloglogs,范围查询等不常用)</p>
<ul>
<li><p>String(字符串):计数器</p>
</li>
<li><p>整数或sds(Simple Dynamic String)</p>
</li>
<li><p>List(列表)：用户的关注，粉丝列表</p>
<ul>
<li>ziplist(连续内存块，每个entry节点头部保存前后节点长度信息实现双向链表功能)或double linked list</li>
</ul>
</li>
<li><p>Hash(哈希)：</p>
</li>
<li><p>Set(集合)：用户的关注者</p>
<ul>
<li>intset或hashtable</li>
</ul>
</li>
<li><p>Zset(有序集合)：实时信息排行榜</p>
<ul>
<li>skiplist(跳跃表)</li>
</ul>
</li>
</ul>
</li>
<li><p>与Memcached区别</p>
<ul>
<li>Memcached只能存储字符串键</li>
<li>Memcached用户只能通过APPEND的方式将数据添加到已有的字符串的末尾，并将这个字符串当做列表来使用。但是在删除这些元素的时候，Memcached采用的是通过黑名单的方式来隐藏列表里的元素，从而避免了对元素的读取、更新、删除等操作</li>
<li>Redis和Memcached都是将数据存放在内存中，都是内存数据库。不过Memcached还可用于缓存其他东西，例如图片、视频等等</li>
<li>虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的Value 交换到磁盘</li>
<li>存储数据安全–Memcached挂掉后，数据没了；Redis可以定期保存到磁盘（持久化）</li>
<li>应用场景不一样：Redis出来作为NoSQL数据库使用外，还能用做消息队列、数据堆栈和数据缓存等；Memcached适合于缓存SQL语句、数据集、用户临时性数据、延迟查询数据和Session等</li>
</ul>
</li>
<li><p>Redis实现分布式锁</p>
<ul>
<li>使用setnx实现加锁，可以同时通过expire添加超时时间</li>
<li>锁的value值可以是一个随机的uuid或者特定的命名</li>
<li>释放锁的时候，通过uuid判断是否是该锁，是则执行delete释放锁</li>
</ul>
</li>
<li><p>常见问题</p>
<ul>
<li><p>缓存雪崩</p>
</li>
<li><p>短时间内缓存数据过期，大量请求访问数据库</p>
</li>
<li><p>缓存穿透</p>
<ul>
<li>请求访问数据时，查询缓存中不存在，数据库中也不存在</li>
</ul>
</li>
<li><p>缓存预热</p>
<ul>
<li>初始化项目，将部分常用数据加入缓存</li>
</ul>
</li>
<li><p>缓存更新</p>
<ul>
<li>数据过期，进行更新缓存数据</li>
</ul>
</li>
<li><p>缓存降级</p>
<ul>
<li>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级</li>
</ul>
</li>
</ul>
</li>
<li><p>一致性Hash算法</p>
<ul>
<li>使用集群的时候保证数据的一致性</li>
</ul>
</li>
<li><p>基于redis实现一个分布式锁，要求一个超时的参数</p>
<ul>
<li>setnx</li>
</ul>
</li>
<li><p>虚拟内存</p>
</li>
<li><p>内存抖动</p>
</li>
</ul>
<h3 id="7-Linux"><a href="#7-Linux" class="headerlink" title="7. Linux"></a>7. Linux</h3><ul>
<li><p>Unix五种i/o模型</p>
<ul>
<li><p>阻塞io</p>
</li>
<li><p>非阻塞io</p>
</li>
<li><p>多路复用io(Python下使用selectot实现io多路复用)</p>
<ul>
<li><p>select</p>
<ul>
<li>并发不高，连接数很活跃的情况下</li>
</ul>
</li>
<li><p>poll</p>
<ul>
<li>比select提高的并不多</li>
</ul>
</li>
<li><p>epoll</p>
<ul>
<li>适用于连接数量较多，但活动链接数少的情况</li>
</ul>
</li>
</ul>
</li>
<li><p>信号驱动io</p>
</li>
<li><p>异步io(Gevent/Asyncio实现异步)</p>
</li>
</ul>
</li>
<li><p>比man更好使用的命令手册</p>
<ul>
<li>tldr:一个有命令示例的手册</li>
</ul>
</li>
<li><p>kill -9和-15的区别</p>
<ul>
<li>-15：程序立刻停止/当程序释放相应资源后再停止/程序可能仍然继续运行</li>
<li>-9：由于-15的不确定性，所以直接使用-9立即杀死进程</li>
</ul>
</li>
<li><p>分页机制（逻辑地址和物理地址分离的内存分配管理方案）：</p>
<ul>
<li><p>操作系统为了高效管理内存，减少碎片</p>
</li>
<li><p>程序的逻辑地址划分为固定大小的页</p>
</li>
<li><p>物理地址划分为同样大小的帧</p>
</li>
<li><p>通过页表对应逻辑地址和物理地址</p>
</li>
</ul>
</li>
<li><p>分段机制</p>
<ul>
<li>为了满足代码的一些逻辑需求</li>
<li>数据共享/数据保护/动态链接</li>
<li>每个段内部连续内存分配，段和段之间是离散分配的</li>
</ul>
</li>
<li><p>查看cpu内存使用情况？</p>
<ul>
<li>top</li>
<li>free 查看可用内存，排查内存泄漏问题</li>
</ul>
</li>
</ul>
<h3 id="8-设计模式"><a href="#8-设计模式" class="headerlink" title="8. 设计模式"></a>8. 设计模式</h3><p><strong>单例模式</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方式一</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Single</span>(<span class="params">cls,*args,**kwargs</span>):</span></span><br><span class="line">        instances = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_instance</span> (<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">                instances[cls] = cls(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> instances[cls]</span><br><span class="line">        <span class="keyword">return</span> get_instance</span><br><span class="line"><span class="meta">    @Single</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 方式二</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Single</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;单例模式实现方式二。。。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    single = Single()</span><br><span class="line">    <span class="keyword">del</span> Single  <span class="comment"># 每次调用single就可以了</span></span><br><span class="line">    <span class="comment"># 方式三(最常用的方式)</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Single</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls,*args,**kwargs</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls,<span class="string">&#x27;_instance&#x27;</span>):</span><br><span class="line">                cls._instance = <span class="built_in">super</span>().__new__(cls,*args,**kwargs)</span><br><span class="line">            <span class="keyword">return</span> cls._instance</span><br></pre></td></tr></table></figure>

<p><strong>工厂模式</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Wang Wang Wang&quot;</span>)</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Miao Miao Miao&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fac</span>(<span class="params">animal</span>):</span></span><br><span class="line">        <span class="keyword">if</span> animal.lower() == <span class="string">&quot;dog&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> Dog()</span><br><span class="line">        <span class="keyword">if</span> animal.lower() == <span class="string">&quot;cat&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> Cat()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;对不起，必须是：dog,cat&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>构造模式</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,serial_number</span>):</span></span><br><span class="line">            self.serial_number = serial_number</span><br><span class="line">            self.memory = <span class="literal">None</span></span><br><span class="line">            self.hadd = <span class="literal">None</span></span><br><span class="line">            self.gpu = <span class="literal">None</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">            info = (<span class="string">f&#x27;Memory:<span class="subst">&#123;self.memoryGB&#125;</span>&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Hard Disk:&#123;self.hadd&#125;GB&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Graphics Card:&#123;self.gpu&#125;&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(info)</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ComputerBuilder</span>：</span></span><br><span class="line"><span class="class">        <span class="title">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">            self.computer = Computer(<span class="string">&#x27;Jim1996&#x27;</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">configure_memory</span>(<span class="params">self,amount</span>):</span></span><br><span class="line">            self.computer.memory = amount</span><br><span class="line">            <span class="keyword">return</span> self <span class="comment">#为了方便链式调用</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">configure_hdd</span>(<span class="params">self,amount</span>):</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">configure_gpu</span>(<span class="params">self,gpu_model</span>):</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HardwareEngineer</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">            self.builder = <span class="literal">None</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">construct_computer</span>(<span class="params">self,memory,hdd,gpu</span>)</span></span><br><span class="line">            self.builder = ComputerBuilder()</span><br><span class="line">            self.builder.configure_memory(memory).configure_hdd(hdd).configure_gpu(gpu)</span><br><span class="line"><span class="meta">        @property</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">computer</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="keyword">return</span> self.builder.computer</span><br></pre></td></tr></table></figure>



<h3 id="9-数据结构和算法内置数据结构和算法"><a href="#9-数据结构和算法内置数据结构和算法" class="headerlink" title="9. 数据结构和算法内置数据结构和算法"></a>9. 数据结构和算法内置数据结构和算法</h3><h4 id="9-1-python实现各种数据结构"><a href="#9-1-python实现各种数据结构" class="headerlink" title="9.1 python实现各种数据结构"></a>9.1 python实现各种数据结构</h4><p><strong>快速排序</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">_list</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(_<span class="built_in">list</span>) &lt; <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> _<span class="built_in">list</span></span><br><span class="line">            pivot_index = <span class="number">0</span></span><br><span class="line">            pivot = _<span class="built_in">list</span>(pivot_index)</span><br><span class="line">            left_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> _<span class="built_in">list</span>[:pivot_index] <span class="keyword">if</span> i &lt; pivot]</span><br><span class="line">            right_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> _<span class="built_in">list</span>[pivot_index:] <span class="keyword">if</span> i &gt; pivot]</span><br><span class="line">        <span class="keyword">return</span> quick_sort(left) + [pivot] + quick_sort(right)</span><br><span class="line">选择排序</span><br></pre></td></tr></table></figure>

<p><strong>选择排序</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span>(<span class="params">seq</span>):</span></span><br><span class="line">        n = <span class="built_in">len</span>(seq)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>)</span><br><span class="line">        min_idx = i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> seq[j] &lt; seq[min_inx]:</span><br><span class="line">                    min_idx = j</span><br><span class="line">            <span class="keyword">if</span> min_idx != i:</span><br><span class="line">                seq[i], seq[min_idx] = seq[min_idx],seq[i]</span><br></pre></td></tr></table></figure>

<p><strong>插入排序</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span>(<span class="params">_list</span>):</span></span><br><span class="line">     n = <span class="built_in">len</span>(_<span class="built_in">list</span>)</span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">         value = _<span class="built_in">list</span>[i]</span><br><span class="line">         pos = i</span><br><span class="line">         <span class="keyword">while</span> pos &gt; <span class="number">0</span> <span class="keyword">and</span> value &lt; _<span class="built_in">list</span>[pos - <span class="number">1</span>]</span><br><span class="line">             _<span class="built_in">list</span>[pos] = _<span class="built_in">list</span>[pos - <span class="number">1</span>]</span><br><span class="line">             pos -= <span class="number">1</span></span><br><span class="line">         _<span class="built_in">list</span>[pos] = value</span><br><span class="line">         <span class="built_in">print</span>(sql)</span><br></pre></td></tr></table></figure>

<p><strong>归并排序</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sorted_list</span>(<span class="params">_list1,_list2</span>):</span>   <span class="comment">#合并有序列表</span></span><br><span class="line">        len_a, len_b = <span class="built_in">len</span>(_list1),<span class="built_in">len</span>(_list2)</span><br><span class="line">        a = b = <span class="number">0</span></span><br><span class="line">        sort = []</span><br><span class="line">        <span class="keyword">while</span> len_a &gt; a <span class="keyword">and</span> len_b &gt; b:</span><br><span class="line">            <span class="keyword">if</span> _list1[a] &gt; _list2[b]:</span><br><span class="line">                sort.append(_list2[b])</span><br><span class="line">                b += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sort.append(_list1[a])</span><br><span class="line">                a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> len_a &gt; a:</span><br><span class="line">            sort.append(_list1[a:])</span><br><span class="line">        <span class="keyword">if</span> len_b &gt; b:</span><br><span class="line">            sort.append(_list2[b:])</span><br><span class="line">        <span class="keyword">return</span> sort</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">_list</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(list1)&lt;<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> list1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mid = <span class="built_in">int</span>(<span class="built_in">len</span>(list1)/<span class="number">2</span>)</span><br><span class="line">            left = mergesort(list1[:mid])</span><br><span class="line">            right = mergesort(list1[mid:])</span><br><span class="line">            <span class="keyword">return</span> merge_sorted_list(left,right)</span><br></pre></td></tr></table></figure>

<p><strong>堆排序heapq模块</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> nsmallest</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span>(<span class="params">_list</span>):</span></span><br><span class="line">      <span class="keyword">return</span> nsmallest(<span class="built_in">len</span>(_<span class="built_in">list</span>),_<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>

<p><strong>栈</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">           self.s = deque()</span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span></span><br><span class="line">           p = self.pop()</span><br><span class="line">           self.push(p)</span><br><span class="line">           <span class="keyword">return</span> p</span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, el</span>):</span></span><br><span class="line">           self.s.append(el)</span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">           <span class="keyword">return</span> self.pop()</span><br></pre></td></tr></table></figure>

<p><strong>队列</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>:</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">          self.s = deque()</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, el</span>):</span></span><br><span class="line">          self.s.append(el)</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">          <span class="keyword">return</span> self.popleft()</span><br></pre></td></tr></table></figure>

<p><strong>二分查找</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">_list,num</span>):</span></span><br><span class="line">     mid = <span class="built_in">len</span>(_<span class="built_in">list</span>)//<span class="number">2</span></span><br><span class="line">     <span class="keyword">if</span> <span class="built_in">len</span>(_<span class="built_in">list</span>) &lt; <span class="number">1</span>:</span><br><span class="line">         <span class="keyword">return</span> Flase</span><br><span class="line">     <span class="keyword">if</span> num &gt; _<span class="built_in">list</span>[mid]:</span><br><span class="line">         BinarySearch(_<span class="built_in">list</span>[mid:],num)</span><br><span class="line">     <span class="keyword">elif</span> num &lt; _<span class="built_in">list</span>[mid]:</span><br><span class="line">         BinarySearch(_<span class="built_in">list</span>[:mid],num)</span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">         <span class="keyword">return</span> _<span class="built_in">list</span>.index(num)</span><br></pre></td></tr></table></figure>



<h3 id="10-面试加强题："><a href="#10-面试加强题：" class="headerlink" title="10. 面试加强题："></a>10. 面试加强题：</h3><ul>
<li><p>关于数据库优化及设计</p>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000018426586">https://segmentfault.com/a/1190000018426586</a></p>
</blockquote>
</li>
<li><p>如何使用两个栈实现一个队列</p>
</li>
<li><p>反转链表</p>
</li>
<li><p>合并两个有序链表</p>
</li>
<li><p>删除链表节点</p>
</li>
<li><p>反转二叉树</p>
</li>
<li><p>设计短网址服务？62进制实现</p>
</li>
<li><p>设计一个秒杀系统(feed流)？</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/ea0259d109f9">https://www.jianshu.com/p/ea0259d109f9</a></p>
</blockquote>
</li>
<li><p>为什么mysql数据库的主键使用自增的整数比较好？使用uuid可以吗？为什么？</p>
<ul>
<li>如果InnoDB表的数据写入顺序能和B+树索引的叶子节点顺序一致的话，这时候存取效率是最高的。为了存储和查询性能应该使用自增长id做主键。</li>
<li>对于InnoDB的主索引，数据会按照主键进行排序，由于UUID的无序性，InnoDB会产生巨大的IO压力，此时不适合使用UUID做物理主键，可以把它作为逻辑主键，物理主键依然使用自增ID。为了全局的唯一性，应该用uuid做索引关联其他表或做外键</li>
</ul>
</li>
<li><p>如果是分布式系统下我们怎么生成数据库的自增id呢？</p>
<ul>
<li>使用redis</li>
</ul>
</li>
<li><p>基于redis实现一个分布式锁，要求一个超时的参数</p>
<ul>
<li>setnx</li>
<li>setnx + expire</li>
</ul>
</li>
<li><p>如果redis单个节点宕机了，如何处理？还有其他业界的方案实现分布式锁码?</p>
</li>
<li><ul>
<li>使用hash一致算法</li>
</ul>
</li>
</ul>
<p><strong>缓存算法</strong></p>
<ul>
<li><p>LRU(least-recently-used):替换最近最少使用的对象</p>
</li>
<li><p>LFU(Least frequently used):最不经常使用，如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小</p>
</li>
</ul>
<p><strong>服务端性能优化方向</strong></p>
<ul>
<li><p>使用数据结构和算法</p>
</li>
<li><p>数据库</p>
<ul>
<li><p>索引优化</p>
</li>
<li><p>慢查询消除</p>
<ul>
<li>slow_query_log_file开启并且查询慢查询日志</li>
<li>通过explain排查索引问题</li>
<li>调整数据修改索引</li>
</ul>
</li>
<li><p>批量操作，从而减少io操作</p>
</li>
<li><p>使用NoSQL:比如Redis</p>
</li>
</ul>
</li>
<li><p>网络io</p>
<ul>
<li>批量操作</li>
<li>pipeline</li>
</ul>
</li>
<li><p>缓存</p>
<ul>
<li>Redis</li>
</ul>
</li>
<li><p>异步</p>
<ul>
<li>Asyncio实现异步操作</li>
<li>使用Celery减少io阻塞</li>
</ul>
</li>
<li><p>并发</p>
<ul>
<li>多线程</li>
<li>Gevent</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
</search>
